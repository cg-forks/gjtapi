<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="AUTHOR" content="Richard Deadman">
   <meta name="CREATED" content="20000518;14325826">
   <meta name="CHANGEDBY" content="Richard Deadman">
   <meta name="CHANGED" content="20000518;14325826">
   <meta name="GENERATOR" content="Mozilla/4.76 [en] (WinNT; U) [Netscape]">
   <meta name="Author" content="Richard Deadman">
   <title>JTAPI Generic Framework Architecture</title>
</head>
<body text="#000000" bgcolor="#FFFFFF" link="#0000EE" vlink="#551A8B" alink="#FF0000">

<center>
<h1>
Generic JTAPI Framework</h1></center>

<center>
<h2>
Architecture Document</h2></center>

<center>Richard Deadman
<br>
<hr WIDTH="80%"></center>

<h2>
<a NAME="Abstract"></a>Introduction</h2>
<font size=-1>The JTAPI Generic Framework is a framework project intended
to provide a common re-usable framework for the development of JTAPI implementations
with a well-known set of capabilities.&nbsp; The framework is an attempt
to balance off the needs for feature-richness with a necessity of making
implementations easier to create.&nbsp; The primary goals were then to:</font>
<ul>
<li>
<font size=-1>Provide a re-usable framework that takes away a lot of the
difficult but repeatable issues of good JTAPI design.&nbsp; JTAPI places
complexity on the implementation in order to give power and ease-of-use
to the applications.&nbsp; The framework attempts to alleviate the complexity
of JTAPI implementation provision by moving it into a re-usable middle
layer.</font></li>

<li>
<font size=-1>Provide a subset of JTAPI functionality that supports the
majority of application telephony needs.</font></li>

<li>
<font size=-1>Increase the availability of JTAPI implementations by reducing
the effort required to support a new platform or IP protocol.</font></li>
</ul>
<font size=-1>This document outlines the overall goals of the framework
and individual sub-architectures that were developed to address facets
of JTAPI implementation requirements, such as event notification and capabilities
determination.</font>
<h2>
<a NAME="Table of Contents"></a>Table of Contents</h2>

<blockquote><a href="#Abstract">Introduction</a>
<br><a href="#Table of Contents">Table of Contents</a>
<br><a href="#Version">Revision History</a>
<br><a href="#Audience">Audience</a>
<br><a href="#Notation">Notation</a>
<br><a href="#Referenced Documents">Referenced Documents</a>
<p><a href="#Overview">1 Overview</a>
<br><a href="#Objective">2 Objective</a>
<br><a href="#Requirements">3 Requirements</a>
<br><a href="#Framework">4 Framework</a>
<br><a href="#Use Cases">5 Use Cases</a>
<br><a href="#Base Architecture">6 Base Architecture</a>
<blockquote><a href="#CRC Cards">6.1 CRC Cards</a>
<br><a href="#Interaction Diagrams">6.2 Interaction Diagrams</a>
<blockquote><a href="#Initialization Interaction Diagram">6.2.1 System
Initialization</a>
<br><a href="#JTAPI command">6.2.2 JTAPI Command</a>
<br><a href="#Raw Provider Call Event">6.2.3 Telephony Provider Call Event</a>
<br><a href="#Raw Provider Media Event">6.2.4 Telephony Provider Media
Event</a>
<br><a href="#Deprecated 1.2 Media Event">6.2.5 Deprecated 1.2 Media Event</a>
<br><a href="#Event Registration">6.2.6 Event Registration</a>
<br><a href="#Event Registration">6.2.7 Exception Handling</a></blockquote>
</blockquote>
<a href="#Component Sub-Architectures">7 Component Sub-Architectures</a>
<blockquote><a href="#Initialization">7.1 Initialization</a>
<br><a href="#Object Mapping">7.2 Object Mapping</a>
<br><a href="#CallId Lifecycle">7.3 CallId Lifecycle</a>
<br><a href="#Event Propagation">7.4 Event Propagation</a>
<br><a href="#Exception Management">7.5 Exception Management</a>
<br><a href="#Remote Support">7.6 Remote Support</a>
<br><a href="#Call Transfer/Conference">7.7 Call Transfer/Conference</a>
<br><a href="#Media Support">7.8 Media Support</a>
<br><a href="#Deprecated 1.2 Media Support">7.9 Deprecated 1.2 Media Support</a>
<br><a href="#Fax">7.10 Fax</a>
<br><a href="#Capabilities">7.11 Capabilities</a>
<br><a href="#Extended JTAPI package support">7.12 Extended JTAPI package
support</a>
<br><a href="#Tuning">7.13 Telephony Provider Tuning</a>
<br><a href="#DynamicAddressing">7.14 Dynamic Domain</a>
<br><a href="#WeakSynchronization">7.15 Weak Synchronization</a>
<blockquote><a href="#WeakProblem">7.15.1 Problem</a>
<br><a href="#WeakOptions">7.15.2 Options</a>
<br><a href="#WeakGoals">7.15.3 Goals</a>
<br><a href="#WeakSimilarProblems">7.15.4 Similar Problems</a>
<br><a href="#WeakAnalysis">7.15.5 Analysis</a>
<br><a href="#WeakArchitecture">7.15.6 Weak Synchronization Architecture</a></blockquote>
</blockquote>
<a href="#Issue Support">8 Issue Support</a>
<blockquote><a href="#AsynchronousSynchronous">8.1 Asynchronous vs. Synchronous</a>
<br><a href="#Multi-Threading">8.2 Multi-Threading</a>
<br><a href="#Callback Dispatch">8.3 Callback Dispatch</a>
<br><a href="#Scalability">8.4 Scalability</a></blockquote>

<div STYLE="margin-left: 0.02cm; text-indent: -0.02cm; margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%"><a href="#Future Work">9
Future Work</a></div>
</blockquote>

<h2>
<a NAME="Version"></a>Revision History</h2>

<blockquote>&nbsp;
<table BORDER >
<tr BGCOLOR="#C0C0C0">
<th>Version</th>

<th>Date</th>

<th>Author</th>

<th>Comment</th>
</tr>

<tr>
<td>
<div align=right>0.2</div>
</td>

<td>
<center>May 23, 2000</center>
</td>

<td>Richard Deadman</td>

<td><font size=-1>Rewrite of the original U|Force "UF-GJTAPI-0001-PLUG"
document into native HTML with a self-contained focus instead of as a "pluggability"
section of a larger document.</font></td>
</tr>

<tr>
<td>
<div align=right>0.3</div>
</td>

<td>
<center>May 30, 2000</center>
</td>

<td>Richard Deadman</td>

<td><font size=-1>Fixed up page colours.&nbsp; Added decorator pattern
comment.&nbsp; Enhanced MedaService discussion.&nbsp; Changed "Raw Provider
Interface" to "Telephony Provider Interface".</font></td>
</tr>

<tr>
<td>
<div align=right>0.4</div>
</td>

<td>
<center>June 27, 2000</center>
</td>

<td>Richard Deadman</td>

<td><font size=-1>Added section on weak synchronization.&nbsp; Updated
event notification threading and dynamic address support.</font></td>
</tr>

<tr>
<td>
<div align=right>0.5</div>
</td>

<td>
<center>September 25, 2002</center>
</td>

<td>Richard Deadman</td>

<td>Minor link and typo corrections.</td>
</tr>
</table>
</blockquote>

<h2>
<a NAME="Audience"></a>Audience</h2>
<font size=-1>This document is intended for developers and maintainers
of the Generic JTAPI Framework.&nbsp; Knowledge of object-oriented design
and programming,&nbsp; Java and, to a lesser extend, JTAPI is expected.&nbsp;
This document is not intended to be a requirements document, although it
certainly covers some aspects of intent and requirements.</font>
<p><font size=-1>Note that developers of TelephonyProviders may find the
"<a href="TpiImplementorsGuide.html">Generic JTAPI TPI Implementor's Guide</a>"
to be more useful.</font>
<h2>
<a NAME="Notation"></a>Notation</h2>
<font size=-1>Normal document typesetting notation is employed within this
document.&nbsp; In particular:</font>
<blockquote>&nbsp;
<table BORDER >
<tr>
<td><tt>Monospaced</tt></td>

<td>Quoted material from another source</td>
</tr>

<tr>
<td><i><tt>Monospaced Italics</tt></i></td>

<td>Example source code (e.g. <i><tt>peer.getProvider("Emulator")</tt></i>)</td>
</tr>

<tr>
<td BGCOLOR="#C0C0C0">Grey Boxes</td>

<td>Indicate proprietary information not to be released past U|Force.</td>
</tr>
</table>
</blockquote>

<h2>
<a NAME="Referenced Documents"></a>Referenced Documents</h2>

<blockquote>&nbsp;
<table BORDER >
<tr>
<td><a href="TpiImplementorsGuide.html">TpiImplementorsGuide.html</a></td>

<td>Generic JTAPI TPI Implementor's Guide</td>
</tr>

<tr>
<td><a href="http://java.sun.com/products/jtapi/">http://java.sun.com/products/jtapi/</a></td>

<td>JTAPI Specification Web Page</td>
</tr>

<tr>
<td>Design Patterns: Elements of Reusable Object-Oriented Software; Gamma
et al., Addison-Wesley Publishing, 1995</td>

<td>Design Patterns</td>
</tr>
</table>
</blockquote>

<h2>
<a NAME="Overview"></a>1 Overview</h2>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%"><font color="#000000"><font size=-1>The
Generic JTAPI Framework is an implementation of the Java Telephony Application
Programming Interface (JTAPI) designed to allow for the support of multiple
telephony boards or IP protocols. It abstracts away implementation details
into a simpler low-level or "raw" interface (called the Telephony Provider
Interface, or TPI, in this document) and provides a common framework to
support non-implementation-specific capabilities.&nbsp; One of the aims
of the architecture is to simplify the development of JTAPI implementations
by reducing the complexity of the interface that must be implemented.&nbsp;
Implementation simplification can be achieved through the following techniques:</font></font>
<ol>
<li>
<font color="#000000"><font size=-1><b>RISC-style reduction in instruction
set</b>.&nbsp; RISC is a hardware processor architecture that replaces
a large set of complex and powerful functions with a smaller set of more
basic functions.&nbsp; The theory is that while source code will now be
compiled to more instructions (because each does less), these instructions
will operate more quickly giving an overall performance gain.&nbsp; JTAPI,
as an application interface, has provided a rich (CISC-style) programming
interface for ease of application development.&nbsp; This can be mapped
to a smaller "instruction set" that makes the low-level implementation
easier.&nbsp; For instance, if we already have hold, join and drop implemented,
we can implement transfer within a middle layer without having to introduce
any new low-level commands.&nbsp; In essence, the Framework is taking on
the job of handling the complexity and providing the best interfaces for
applications (large, feature-rich API) and low-level implementations (small
API).</font></font></li>

<li>
<font color="#000000"><font size=-1><b>Reduction in capabilities</b>.&nbsp;
There is an old saying that 20% of code performs 80% of all functionality.&nbsp;
JTAPI is a rich API that provides every imaginable telephony capability.&nbsp;
Not all of these are appropriate to all platforms, nor is it necessarily
feasible to implement all of them for every provider.&nbsp; Do we need
CallAgent support on modem-based TAPI phones?&nbsp; Busy-lamp control over
1950's analog phones connected to a PSTN?&nbsp; The goal of the framework
was to define a subset of commonly-used functionality that would satisfy
the most common application requirements.&nbsp; (<i>It is recognized that
this is a judgement call -- more later on an <a href="#Extended JTAPI package support">extension
framewor</a></i><a href="#Extended JTAPI package support">k</a>)</font></font></li>

<li>
<font color="#000000"><font size=-1><b>High-level handling of management
issues</b>.&nbsp; JTAPI provides some functions which are not directly
telephony related, such as semantics for call event monitoring.&nbsp; Since
these semantics are not implementation specific (tracking Terminal-registered
CallListeners does not depend on the low-level telephony implementation),
we can handle these within the framework and isolate the complexity from
the provider.&nbsp; Other areas ripe for simplicity include:</font></font></li>

<ul>
<li>
<font color="#000000"><font size=-1>event broadcast</font></font></li>

<li>
<font color="#000000"><font size=-1>remote distribution</font></font></li>

<li>
<font color="#000000"><font size=-1>capabilities determination on instances</font></font></li>
</ul>
</ol>
</div>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%"><font color="#000000"><font size=-1>The
Generic JTAPI implementation will talk to the vendor-specific or protocol
layer through a pluggable interface. This interface effectively separates
the re-usable JTAPI object model from proprietary or protocol-based details.
The reasons for this API interface for vendor decoupling, as opposed to
a wire protocol or JNI interface, include:</font></font></div>

<ol>
<li STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<font color="#000000"><font size=-1>No lock-in to a particular distribution
or native architecture. A JNI interface would mean that any IP protocol
would have to be mapped through a native shared library or DLL needlessly.
Similarly, specifying a wire protocol to talk to a server will impose performance
penalties when the client and server are on the same machine.</font></font></li>

<li STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<font color="#000000"><font size=-1>Support for modular code defined by
interfaces. This not only allows for pluggable configuration, it also supports
test harnesses and eases parallel development and early testing.</font></font></li>

<li STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<font color="#000000"><font size=-1>Ability to build proxies (GOF: pp.
207). By inserting a remote proxy between the generic code and an Linkon-specific
implementation, for instance, allows us to transparently make the NMS implementation
remote.</font></font></li>

<li STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<font color="#000000"><font size=-1>Ability to provide a test harness.
A pure Java test implementation can be built for development and testing
of the generic framework without requiring telephony hardware and licences
for each developer.</font></font></li>
</ol>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%"><font color="#000000"><font size=-1>This
document will review the overall framework, define use cases and requirements,
the current architecture and low-level API, including CRC cards and Interaction
diagrams. Of particular interest will be:</font></font></div>

<ul>
<li STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<font color="#000000"><font size=-1>How a plugged-in layer is initialized</font></font></li>

<li STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<font color="#000000"><font size=-1>How events are handled</font></font></li>

<li STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<font color="#000000"><font size=-1>How exceptions are handled</font></font></li>

<li STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<font color="#000000"><font size=-1>How capabilities are set</font></font></li>

<li STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<font color="#000000"><font size=-1>How multi-threading is supported</font></font></li>
</ul>

<h2>
<a NAME="Objective"></a>2 Objective</h2>
<font color="#000000"><font size=-1>Provide as simple framework for low-level
provider implementation as possible. Any complexity in object relationship
management must be handled in the Generic JTAPI Framework classes. (We
can assume that the testing of the framework to low-level implementation
will be much better than the testing of JTAPI applications, and so does
not need as robust error trapping).</font></font>
<p><font color="#000000"><font size=-1>A low-level implementation must
be at least an order of magnitude easier to implement than a full-blown
JTAPI implementation from scratch.</font></font>
<h2>
<a NAME="Requirements"></a>3 Requirements</h2>

<ol>
<li>
<font size=-1>The framework will implement the following parts of JTAPI:</font></li>

<ul>
<li>
<font size=-1>All core functionality</font></li>

<li>
<font size=-1>Under "callcontrol": hold, unhold, transfer, conference,
release</font></li>

<li>
<font size=-1>Media control (version 1.3)</font></li>

<li>
<font size=-1>Deprecated 1.2 Media Control</font></li>
</ul>

<li>
<font color="#000000"><font size=-1>The low-level (TPI) interface should
use the same synchronous paradigm as JTAPI. Depending on the JTAPI method,
some actions are synchronously invoked and some are simply started, with
their completion indicated by events. Forcing a shift in paradigm above
a pluggable layer may lead to a correcting shift below if it turns out
that the vendor API or protocol has the same paradigm as JTAPI.</font></font></li>

<li>
<font color="#000000"><font size=-1>The low-level (TPI) interface should
be as small as possible. If there is more than a couple of classes to implement
and co-ordinate the relationship between, then the job of implementing
the interface hierarchy and relationships will detract from the goal of
easily implementable and hooked-in low-level providers.</font></font></li>

<li>
<font color="#000000"><font size=-1>A flexible and simple property loading
system must be in place.</font></font></li>

<li>
<font color="#000000"><font size=-1>The framework must support concurrency.</font></font></li>

<li>
<font color="#000000"><font size=-1>The system must support scalability.</font></font></li>

<li>
<font size=-1>The system may be distributed by the insertion of a "proxy"
provider between the framework and the true "telephony provider".</font></li>
</ol>

<h2>
<a NAME="Framework"></a>4 Framework</h2>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%"><font color="#000000"><font size=-1>The
following diagram presents a component-level view of the proposed architecture.
Further sections will discuss the components and their interface requirements
at a lower-level.</font></font></div>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">&nbsp;
<center><table BORDER CELLPADDING=10 BGCOLOR="#C0C0C0" >
<tr>
<td><img SRC="JtapiGenericFramework_Framework.gif" NAME="Components" ALT="Components" height=283 width=547>
<center><i>Note: The "Multiplexor portion of this diagram is proprietary
to U|Force.</i></center>
</td>
</tr>
</table></center>

<p><font size=-1>We note in particular that the development of a low-level
"telephony provider interface" allows us to apply the Decorator Pattern
to usages of the Framework.&nbsp; From Gamma et al, we can take the Decorator
Intent:</font>
<blockquote><tt><font size=-1>Attach additional responsibilities to an
object dynamically.&nbsp; Decorators provide a flexible alternative to
subclassing for extending functionality.</font></tt></blockquote>
<font size=-1>In essense, a decorator allows an object to be wrapped in
an object that delegates off core responsibility to the wrapped object
and "decorates" itself with additional capabilities.&nbsp; In the case
of the above diagram, the "Optional Remote Proxy" is a decorator for the
"Emulator Provider".&nbsp; It delegates off low-level TPI calls to the
Emulator Provider but decorates the Emulator Provider with remote accessing
capabilities.</font></div>

<h2>
<a NAME="Use Cases"></a>5 Use Cases</h2>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%"><font color="#000000"><font size=-1>JTAPI
is a complex and well-documented API and it is not our purpose to repeat
the Use Cases of JTAPI commands here.&nbsp; For more information on the
intended behaviour of JTAPI commands, see the JTAPI documentation for the
functions listed as supported in the following implementation chart.</font></font>
<blockquote>&nbsp;
<table BORDER >
<tr BGCOLOR="#C0C0C0">
<th>JTAPI Package</th>

<th>Class</th>

<th>Supported</th>

<th>Unsupported</th>
</tr>

<tr>
<td>core</td>

<td>Address, Call, Connection, Terminal, TerminalConnection</td>

<td>All</td>

<td></td>
</tr>

<tr>
<td>callcenter</td>

<td></td>

<td></td>

<td>All</td>
</tr>

<tr>
<td>callcontrol</td>

<td>CallControlAddress</td>

<td></td>

<td>All</td>
</tr>

<tr>
<td></td>

<td>CallControlCall</td>

<td>addParty
<br>conference
<br>consult(TerminalConnection, String)
<br>drop
<br>getConferenceController
<br>getConferenceEnabled
<br>getTransferController
<br>getTransferEnabled
<br>setConferenceController
<br>setConferenceEnabled
<br>setTransferController
<br>setTransferEnabled
<br>transfer(Call)
<br>transfer(String)</td>

<td>consult(TerminalConnection)
<br>getCalledAddress
<br>getCalledAddress
<br>getCallingTerminal
<br>getLastRedirectedAddress
<br>offHook</td>
</tr>

<tr>
<td></td>

<td>CallControlConnection</td>

<td></td>

<td>All</td>
</tr>

<tr>
<td></td>

<td>CallControlTerminal</td>

<td></td>

<td>All</td>
</tr>

<tr>
<td></td>

<td>CallControlTerminalConnection</td>

<td>getCallControlState
<br>hold
<br>unhold</td>

<td>join
<br>leave</td>
</tr>

<tr>
<td>media</td>

<td>1.3 Media (MediaTerminal, MediaProvider, MediaService)</td>

<td>All (renamed BasicMediaService to GenericMediaService due to JTAPI
specification error)</td>

<td></td>
</tr>

<tr>
<td></td>

<td>MediaTerminalConnection (1.2 deprecated)</td>

<td>All</td>

<td></td>
</tr>

<tr>
<td>mobile</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>phone</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>privatedata</td>

<td></td>

<td></td>

<td></td>
</tr>
</table>
</blockquote>
<font color="#000000"><font size=-1>&nbsp;To see how these Use Cases are
mapped to the proposed low-level pluggable API, see the section outlining
the Interaction Diagrams.</font></font></div>

<h2>
<a NAME="Base Architecture"></a>6 Base Architecture</h2>
<font color="#000000"><font size=-1>The following is a simplified class
diagram for the TelephonyProvider and its association with the Uforce JTAPI
Peer and Providers. Note that not all methods are shown in this diagram.
Since the diagram was generated, the following changes have occurred:</font></font>
<ul>
<li>
<font color="#000000"><font size=-1>RawException has been superseded. It
was decided that low-level functions would just be able to throw the same
exceptions as their corresponding high-level JTAPI functions. This required,
however, the creation of a RawStateException that allows for the encapsulation
of the information required to eventually throw an InvalidStateException
from the JTAPI framework layer.</font></font></li>

<li>
<font color="#000000"><font size=-1>RawProvider was renamed to TelephonyProvider
for clarity.</font></font></li>

<li>
<font color="#000000"><font size=-1>Similarily, RawListener was renamed
to TelephonyListener</font></font></li>
</ul>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%"><font color="#000000"><font size=-1>One
option that was considered for CallIds was mapping call ids to longs (or
Longs) and then letting the telephony provider map these through some dictionary
to its idea of a call id.&nbsp; It seemed more efficient and cleaner, however,
to create a CallId interface and let each telephony provider have its call
ids implement this (empty) interface.</font></font></div>

<p><br><img SRC="JtapiGenericFramework_RawProviderClassDiagram.jpg" NAME="Graphic1" BORDER=0 height=436 width=670 align=TEXTTOP>
<br>&nbsp;
<br>&nbsp;
<blockquote>
<h3>
<a NAME="CRC Cards"></a>6.1 CRC Cards</h3>
</blockquote>

<center><table BORDER CELLSPACING=0 CELLPADDING=4 WIDTH="480" BORDERCOLOR="#000000" STYLE="page-break-inside: avoid" >
<tr>
<th VALIGN=TOP COLSPAN="2" WIDTH="470">TelephonyProvider</th>
</tr>

<tr VALIGN=TOP>
<td WIDTH="231">
<center><b>Responsibility</b></center>
</td>

<td WIDTH="231">
<center><b>Collaborator</b></center>
</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="231">
<div STYLE="margin-top: 0.42cm"><font color="#000000"><font size=-1>Provide
implementation specific properties</font></font></div>
</td>

<td WIDTH="231">
<div STYLE="margin-top: 0.42cm"><i><font color="#000000"><font size=-1>(Properties
and corresponding file)</font></font></i></div>
</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="231">
<div STYLE="margin-top: 0.42cm"><font color="#000000"><font size=-1>Register
and unregister Listeners</font></font></div>
</td>

<td WIDTH="231">&nbsp;</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="231">
<div STYLE="margin-top: 0.42cm"><font color="#000000"><font size=-1>Control
basic telephony functions</font></font></div>
</td>

<td WIDTH="231">&nbsp;</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="231">
<div STYLE="margin-top: 0.42cm"><font color="#000000"><font size=-1>Manage
DTMF playing and recording</font></font></div>
</td>

<td WIDTH="231">&nbsp;</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="231">
<div STYLE="margin-top: 0.42cm"><font color="#000000"><font size=-1>Manage
audio playing and recording</font></font></div>
</td>

<td WIDTH="231">&nbsp;</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="231">
<div STYLE="margin-top: 0.42cm"><font color="#000000"><font size=-1>Manage
Fax sending and receiving</font></font></div>
</td>

<td WIDTH="231">&nbsp;</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="231">
<div STYLE="margin-top: 0.42cm"><font color="#000000"><font size=-1>Allow
for the reservation and release of CallIds</font></font></div>
</td>

<td WIDTH="231">&nbsp;</td>
</tr>
</table></center>

<br>&nbsp;
<center><table BORDER CELLSPACING=0 CELLPADDING=4 WIDTH="480" BORDERCOLOR="#000000" STYLE="page-break-inside: avoid" >
<tr>
<th VALIGN=TOP COLSPAN="2" WIDTH="470">TelephonyListener</th>
</tr>

<tr VALIGN=TOP>
<td WIDTH="231">
<center><b>Responsibility</b></center>
</td>

<td WIDTH="231">
<center><b>Collaborator</b></center>
</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="231">
<div STYLE="margin-top: 0.42cm"><font color="#000000"><font size=-1>Observe
telephony events generated by the TelephonyProvider</font></font></div>
</td>

<td WIDTH="231">&nbsp;</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="231">
<div STYLE="margin-top: 0.42cm"><font color="#000000"><font size=-1>Forward
events</font></font></div>
</td>

<td WIDTH="231">
<div STYLE="margin-top: 0.42cm"><i><font color="#000000"><font size=-1>GenericProvider</font></font></i></div>
</td>
</tr>
</table></center>

<br>&nbsp;
<center><table BORDER CELLSPACING=0 CELLPADDING=4 WIDTH="480" BORDERCOLOR="#000000" STYLE="page-break-inside: avoid" >
<tr>
<th VALIGN=TOP COLSPAN="2" WIDTH="470">RawStateException</th>
</tr>

<tr VALIGN=TOP>
<td WIDTH="231">
<center><b>Responsibility</b></center>
</td>

<td WIDTH="231">
<center><b>Collaborator</b></center>
</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="231">
<div STYLE="margin-top: 0.42cm"><font color="#000000"><font size=-1>Encapsulate
low-level state exception</font></font></div>
</td>

<td WIDTH="231">&nbsp;</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="231">
<div STYLE="margin-top: 0.42cm"><font color="#000000"><font size=-1>Create
a InvalidStateException</font></font></div>
</td>

<td WIDTH="231">
<div STYLE="margin-top: 0.42cm"><font color="#000000"><font size=-1>GenericProvider</font></font></div>
</td>
</tr>
</table></center>

<br>&nbsp;
<center><table BORDER CELLSPACING=0 CELLPADDING=4 WIDTH="480" BORDERCOLOR="#000000" STYLE="page-break-inside: avoid" >
<tr>
<th VALIGN=TOP COLSPAN="2" WIDTH="470">CallId</th>
</tr>

<tr VALIGN=TOP>
<td WIDTH="231">
<center><b>Responsibility</b></center>
</td>

<td WIDTH="231">
<center><b>Collaborator</b></center>
</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="231">
<div STYLE="margin-top: 0.42cm"><font color="#000000"><font size=-1>Encapsulate
TelephonyProvider specific call identity</font></font></div>
</td>

<td WIDTH="231">&nbsp;</td>
</tr>
</table></center>

<blockquote>
<h3>
<a NAME="Interaction Diagrams"></a>6.2 Interaction Diagrams</h3>
</blockquote>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote><font color="#000000"><font size=-1>The following interaction
diagrams do not map directly to JTAPI API calls or Use Cases, but rather
to classes of similar behaviour in the system.&nbsp; For instance, the
system may be thought of as having several co-ordinated facets:</font></font>
<ul>
<li>
<font color="#000000"><font size=-1>Initialization phase, during which
the GenericProvider creates, configures and interrogates its TelephonyProvider
in order to create an initial state for the system.</font></font></li>

<li>
<font color="#000000"><font size=-1>JTAPI command handling, during which
commands are sent to the TelephonyProvider to control an aspect of the
telephony system.</font></font></li>

<li>
<font color="#000000"><font size=-1>Event registration, during which applications
register with the framework for JTAPI events.&nbsp; This may lead the framework
to turn on low-level event reporting.</font></font></li>

<li>
<font color="#000000"><font size=-1>Event handling, in which telephony
events from a Telephony Provider are received and used to update the system
state machine which in turn generates JTAPI events to registered applications.</font></font></li>

<li>
<font color="#000000"><font size=-1>Exception handling from low-level commands.
These may optionally be "morphed" into the object-model of the Framework
before being reported back to the calling application.</font></font></li>
</ul>
<i><font color="#000000"><font size=-1>Note: The following diagrams have
not been completed at this time.</font></font></i></blockquote>
</div>

<blockquote>
<blockquote>
<h4>
<a NAME="Initialization Interaction Diagram"></a>6.2.1 Initialization</h4>
</blockquote>
</blockquote>

<ol>
<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote>
<blockquote>
<li>
<font color="#000000"><font size=-1>The GenericJtapiPeer is sent the message
"<tt>Provider getProvider(String param)</tt>"</font></font></li>

<li>
<font color="#000000"><font size=-1>The GenericJtapiPeer parses the parameter
string for a sub-provider name and any appended name-value properties.</font></font></li>

<li>
<font color="#000000"><font size=-1>The GenericJtapiPeer checks if the
sub-provider name is null and then chooses the default TelephonyProvider
class.</font></font></li>

<li>
<font color="#000000"><font size=-1>Otherwise the GenericJtapiPeer determines
the TelephonyProviderClassName from its look-up table</font></font></li>

<li>
<font color="#000000"><font size=-1>An instance of the TelephonyProvider
is created.</font></font></li>

<li>
<font color="#000000"><font size=-1>The GenericJtapiPeer creates a GenericProvider
with the TelephonyProvider and the parameters.</font></font></li>

<li>
<font color="#000000"><font size=-1>The GenericProvider initializes the
TelephonyProvider with the passed in parameters.</font></font></li>

<li>
<font color="#000000"><font size=-1>The TelephonyProvider chooses how to
use the parameters with any of its own values.</font></font></li>

<li>
<font color="#000000"><font size=-1>The GenericProvider queries the TelephonyProvider
for an updated capabilities set, and uses this to build the static Capabilities
objects.</font></font></li>

<li>
<font color="#000000"><font size=-1>The GenericProvider asks the TelephonyProvider
for a lists of all Address names.</font></font></li>

<li>
<font color="#000000"><font size=-1>For each address name, the GenericProvider
asks the TelephonyProvider for the associated terminal names.</font></font></li>

<li>
<font color="#000000"><font size=-1>For each terminal name, the GenericProvider
asks the TelephonyProvider if it should instantiate a MediaTerminal instance
or a regular Terminal instance.</font></font></li>

<li>
<font color="#000000"><font size=-1>The GenericProvider creates its fixed
Address and Terminal collections.</font></font></li>
</blockquote>
</blockquote>
</div>

<ol>
<h4>
<a NAME="JTAPI command"></a>6.2.2 JTAPI command</h4>

<ol>
<li>
<font size=-1>An application invokes a command on a JTAPI object instantiated
by the JTAPI framework</font></li>

<li>
<font size=-1>The object asks the GenericProvider for a handle on the telephony
provider.</font></li>

<li>
<font size=-1>The object translates its identity to the TelephonyProvider
frame of reference (see <a href="#Object Mapping">7.2 Object Mapping</a>)</font></li>

<li>
<font size=-1>The object sends the corresponding TelephonyProvider command(s)
to the telephony provider.</font></li>

<li>
<font size=-1>The object maps any return value to the appropriate JTAPI
return value.</font></li>

<li>
<font size=-1>The object returns the return value</font></li>
</ol>
<i><font size=-1>Note: Issuing a JTAPI command does not directly cause
a state change in any corresponding JTAPI object.&nbsp; State changes are
always driven by events from the telephony provider.</font></i>
<h4>
<a NAME="Raw Provider Call Event"></a>6.2.3Telephony Provider Call Event</h4>

<ol>
<li>
<font size=-1>The telephony provider invokes a <font color="#000000">TelephonyListener</font>
callback method.</font></li>

<li>
<font size=-1>The generic framework receives the event.</font></li>

<li>
<font size=-1>The generic framework looks up the referenced JTAPI objects.&nbsp;
With the exception of "drop" events, these will be lazily initialized if
necessary.</font></li>

<li>
<font size=-1>The generic framework issues the appropriate state change
event on the object(s).</font></li>

<li>
<font size=-1>The updated object may issue Observer and Listener events
to any registered applications.</font></li>
</ol>

<h4>
<a NAME="Raw Provider Media Event"></a>6.2.4 Telephony Provider Media Event</h4>

<ol>
<li>
<font size=-1>The telephony provider invokes a <font color="#000000">TelephonyListener</font>
media callback method.</font></li>

<li>
<font size=-1>The generic framework receives the event.</font></li>

<li>
<font size=-1>The generic framework looks up the referenced JTAPI MediaService.</font></li>

<li>
<font size=-1>The generic framework creates an appropriate MediaEvent object.</font></li>

<li>
<font size=-1>The generic framework asks the MediaService for its listeners.</font></li>

<li>
<font size=-1>The generic framework forwards the event off the the appropriate
method on each listener.</font></li>
</ol>

<h4>
<a NAME="Deprecated 1.2 Media Event"></a>6.2.5 Deprecated 1.2 Media Event</h4>
<font size=-1>Note: The 1.2 Media classes piggyback on the 1.3 media support
by creating a pseudo-MediaService that manages registration with the MediaMgr
object and intercepts Listener events so as to create the appropriate MediaTerminalConnectionObserver
events.</font>
<ol START=7>
<li>
<font size=-1>The MediaListener notifices a pseudo-MediaService associated
with a TerminalConnection.</font></li>

<li>
<font size=-1>The pseudo-MediaService creates an Observer event and sends
it to the TerminalConnection's Observers.</font></li>
</ol>

<h4>
<a NAME="Event Registration"></a>6.2.6 Event Registration</h4>

<ol>
<li>
<font size=-1>An application registers a Listener or Observer with a JTAPI
object (Call, Terminal, Address).</font></li>

<li>
<font size=-1>If the registration is with a Terminal or Address, the framework:</font></li>

<ol>
<li>
<font size=-1>Registers the call in a pool for application to future calls
to visit the Terminal or Address</font></li>

<li>
<font size=-1>Registers the Observer or Listener with any currently active
calls on the Terminal or Address.</font></li>

<li>
<font size=-1>Notes the Call registration as being only while the Call
is attached to the Terminal or Address.</font></li>
</ol>
</ol>
<i><font size=-1>Note that a ListenerManager is in place in the Framework
for tracking the status of Observer and Listener associations with Calls.&nbsp;
More later in the section titled <a href="#Event Propagation">Event Propagation</a>.</font></i>
<h4>
<a NAME="Exception Handling"></a>6.2.7 Exception Handling</h4>

<ol>
<li>
<font size=-1>A telephony provider raises an exception to an application-driven
telephony-provider method invocation.</font></li>

<li>
<font size=-1>The framework passes the event on to the calling application,
except in the case of a RawStateException:</font></li>

<ol>
<li>
<font size=-1>The framework catches the RawStateException</font></li>

<li>
<font size=-1>The framework asks the RawStateException to create an InvalidStateException
using its internal state and the passed in GenericProvider (Visitor and
Factory Patterns)</font></li>

<li>
<font size=-1>The framework throws the InvalidStateException.</font></li>
</ol>
</ol>
<i><font size=-1>See <a href="#Exception Management">Exception Management</a></font></i></ol>
</ol>

<h2>
<a NAME="Component Sub-Architectures"></a>7 Component Sub-Architectures</h2>

<blockquote>
<h3>
<a NAME="Initialization"></a>7.1 Initialization</h3>
</blockquote>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote><font color="#000000"><font size=-1>When the GenericJtapiPeer
is sent the message "getProvider(String foo)", it will always return an
instance of GenericProvider. The GenericJtapiPeer will load its own Properties
object from a "properties" file that not only defines high-level properties,
including maybe default capabilities, but also the following properties:</font></font>
<blockquote>
<pre><font color="#000000"><font size=-1>DefaultProvider = Emulator</font></font></pre>
</blockquote>
</blockquote>
</div>

<ul>
<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote><font color="#000000"><font size=-1>A set of TelephonyProviderName:TelephonyProviderClassName
pairs, with keys prepended with the prefix "<tt>PROVIDER</tt>", i.e.</font></font>
<blockquote>
<pre><font color="#000000"><font size=-1>PROVIDER_Emulator = com.uforce.jtapi.generic.raw.emulator.EmProvider</font></font></pre>
</blockquote>
</blockquote>
</div>
</ul>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote><font color="#000000"><font size=-1>The basic algorithm is:</font></font></blockquote>
</div>

<ol>
<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote>
<blockquote>
<li>
<font color="#000000"><font size=-1>The local peer properties file is read
for a list of sub-provider (name : fullyQualifiedClassName) pairs.</font></font></li>

<li>
<font color="#000000"><font size=-1>The string foo is parsed for a sub-provider
name and any name-value properties. So "Rmi;name=foo;server=bar" will indicate
that the RMI sub-provider is requested, with two properties.</font></font></li>

<li>
<font color="#000000"><font size=-1>If "foo" is null or an empty string,
the default sub-provider is used.</font></font></li>

<li>
<font color="#000000"><font size=-1>If "foo" is not a key in the provider
list, it is assumed to be the fully qualified path name of the sub-provider.</font></font></li>

<li>
<font color="#000000"><font size=-1>The selected sub-provider class is
loaded and instantiated.</font></font></li>

<li>
<font color="#000000"><font size=-1>The selected sub-provider is initialized
with the passed-in properties. It is up to the sub-provider to determine
the semantics of these properties, and if they should replace or append
any property-file loaded properties.</font></font></li>

<li>
<font color="#000000"><font size=-1>The GenericProvider instance asks the
sub-provider for any changes to the basic capability set for the five base
telephony operations. These new values are used to build the static Capabilities
set.</font></font></li>

<li>
<font color="#000000"><font size=-1>The GenericProvider instance interrogates
the sub-provider for Address and Terminal names and builds its collection
of Address and Terminal objects. For each terminal name returned, the sub-provider
is asked if that terminal supports media services. If it does, the appropriate
MediaTerminal instance is created and stored.</font></font></li>

<li>
<font color="#000000"><font size=-1>The GenericProvider is returned to
the calling application.</font></font></li>
</blockquote>
</blockquote>
</div>
</ol>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote><font color="#000000"><font size=-1>Thus, the Generic JTAPI
framework take the responsibility for parsing property strings and initializing
a Provider hooked to a plugged-in low-level "raw" telephony provider.</font></font></blockquote>
</div>

<blockquote>
<h3>
<a NAME="Object Mapping"></a>7.2 Object Mapping</h3>
</blockquote>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote><font color="#000000"><font size=-1>One of the goals of the
Generic JTAPI framework is to reduce the amount of work required to build
a low-level provider. For this reason, the low-level provider is not exposed
to the JTAPI object level, but instead deals with call ids, address names
and terminal names. We note that these are sufficient to uniquely identify
any basic JTAPI object (excluding the Provider, of course):</font></font></blockquote>
</div>

<center><table BORDER CELLSPACING=0 CELLPADDING=4 BORDERCOLOR="#000000" >
<caption><b>JTAPI Object to <font color="#000000">TelephonyProvider</font>
reference mapping</b></caption>

<tr VALIGN=TOP>
<th WIDTH="25%">Object</th>

<th WIDTH="25%">CallId</th>

<th WIDTH="25%">Address Name</th>

<th WIDTH="25%">Terminal Name</th>
</tr>

<tr VALIGN=TOP>
<td WIDTH="25%">Call</td>

<td WIDTH="25%">X</td>

<td WIDTH="25%"></td>

<td WIDTH="25%"></td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="25%">Address</td>

<td WIDTH="25%"></td>

<td WIDTH="25%">X</td>

<td WIDTH="25%"></td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="25%">Terminal</td>

<td WIDTH="25%"></td>

<td WIDTH="25%"></td>

<td WIDTH="25%">X</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="25%">Connection</td>

<td WIDTH="25%">X</td>

<td WIDTH="25%">X</td>

<td WIDTH="25%"></td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="25%">TerminalConnection</td>

<td WIDTH="25%">X</td>

<td WIDTH="25%">X</td>

<td WIDTH="25%">X</td>
</tr>
</table></center>

<blockquote>
<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%"><font color="#000000"><font size=-1>Thus,
while JTAPI may deal with the five objects in the left-hand column, the
sub-provider deals with simpler CallId objects and strings. This facilitates
easy serialization (over a socket, for instance) of the connection between
the JTAPI framework and the sub-provider, as well as decoupling the sub-provider
from the intricacies of managing JTAPI object relationships.</font></font></div>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%"><font color="#000000"><font size=-1>This
mapping is key to understanding some of the requirements of the Generic
JTAPI framework. For instance, while most JTAPI exceptions may be thrown
directly by the sub-provider, InvalidStateException (which requires a handle
on the object with the invalid state) may not. Instead, a RawStateException
object, with the same information using primitive types, is thrown instead.
The Generic JTAPI framework takes the responsibility for transforming the
RawStateException object into the appropriate InvalidStateException object.</font></font></div>

<h3>
<a NAME="CallId Lifecycle"></a>7.3 CallId Lifecycle</h3>
</blockquote>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote><font color="#000000"><font size=-1>CallIds are unique sub-provider
references to logical calls. The Generic JTAPI Framework makes no assumptions
about the reference, other than that "equals()" behaves appropriately.
CallId instances are mapped to JTAPI Call objects.</font></font></blockquote>
</div>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote><font color="#000000"><font size=-1>Calls can be created in
two ways:</font></font></blockquote>
</div>

<ol>
<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote>
<li>
<font color="#000000"><font size=-1>An event is sent from the sub-provider
that a new call has appeared. The JTAPI layer will check if the event maps
to a known Call object. If it does not, a new Call object is created.</font></font></li>
</blockquote>
</div>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote>
<li>
<font color="#000000"><font size=-1>An application asks the Provider for
a new Call object. In this case, the Call object reserves a low-level CallId
from the sub-provider.&nbsp; (This pre-reservation requirement is explained
in the following discussion)</font></font></li>
</blockquote>
</div>
</ol>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote><font color="#000000"><font size=-1>We have to be careful in
the timing of CallId creation and destruction, or we can lead to duplicate
Call objects or Call commands send to the wrong Call. During creation,
a CallId must be pre-allocated prior to the Call being started. If it is
not, there is a risk that the call start will create Call events from the
TelephonyProvider that will appear back in the framework before the createCall()
method returns. Since no CallId has been pre-allocated, the Framework does
not know that this is a call it is in the process of creating and instead
creates a duplicate Call object.</font></font></blockquote>
</div>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote><font color="#000000"><font size=-1>Similarly, the TelephonyProvider
should not recycle CallIds until the Framework has reported that it has
also finished with the Call. Otherwise there is a chance that, due to message
latency, the Framework will request a Call action on a CallId that has
already gone to idle and been recycled for a new call.</font></font></blockquote>
</div>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote><font color="#000000"><font size=-1>Since no other requirements
are placed on CallId other than that they respect "equals", we must be
careful during remote serialization. Serialization may cause problems in
that "equals" may rely on object "=" which is broken by the deep-copy of
RMI (for instance). Serialization also imposes restrictions on how transient
and non-transient fields should be assigned to CallId implementations.
There are two approaches we could take here:</font></font>
<ol>
<li>
<font color="#000000"><font size=-1>Impose extra semantic restrictions
on the CallId implementation (i.e. The generation and maintenance of a
serialization unique id).</font></font></li>

<li>
<font color="#000000"><font size=-1>Delegate the remote identity problem
to the remote proxy layer.</font></font></li>
</ol>
</blockquote>
</div>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote><font color="#000000"><font size=-1>As part of the general
philosophy of keeping the sub-provider requirements as simple as possible
and centralizing the complexity in the re-usable pieces, the latter approach
has been taken. See the discussion below on <a href="#Remote Support">Remote
proxies</a>.</font></font></blockquote>
</div>

<blockquote>
<h3>
<a NAME="Event Propagation"></a>7.4 Event Propagation</h3>
</blockquote>

<blockquote>
<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%"><font color="#000000"><font size=-1>In
the Generic JTAPI Framework architecture, the framework is decoupled from
the telephony implementation through the use of the TelephonyProvider and
TelephonyListener interface.&nbsp; The TelephonyProvider interface defines
how the Generic Framework issues telephony commands to the telephony system.&nbsp;
Conversely, the telephony system (board, VOIP, PBX interface) must relay
asynchronous state information back to the Generic JTAPI Framework (new
call arrived, terminal on hold, connection dropped).&nbsp; The goal is
to provide as simple an "event" notification interface to TelephonyProviders
as is possible, letting the Generic Framework handle any morphing of event
information.</font></font></div>
</blockquote>

<blockquote>
<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%"><font color="#000000"><font size=-1>JTAPI,
prior to 1.3, used the traditional Observer pattern for indicating object
state changes.&nbsp; In the Observer pattern, an event is passed which
encapsulates state change type information as well as details.&nbsp; Events
could be sent in batches, such as for a series of events related to a transfer.</font></font></div>
</blockquote>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote><font color="#000000"><font size=-1>In JTAPI 1.3, the Observer
pattern was deprecated in favour of the more object-oriented Listener pattern.&nbsp;
The Listener pattern is more explicit (strongly typed) in that the event
change type was moved from parameter type to Listener method selector.&nbsp;
Whereas with Observers we would have called:</font></font>
<blockquote>
<pre><font color="#000000"><font size=-1>CallObserver.callChangedEvent(CallEv[] events)</font></font></pre>
</blockquote>
<font color="#000000"><font size=-1>passing in an array of <tt>CallEv</tt>
sub-types, with Listeners we make several calls to the CallListener, such
as</font></font></blockquote>
</div>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote>
<blockquote>
<pre><font color="#000000"><font size=-1>CallListener.callActive(CallEvent event).</font></font></pre>
</blockquote>
</blockquote>
</div>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote><font color="#000000"><font size=-1>One of the restrictions
of the Listener pattern is that we lose group event information.&nbsp;
To counteract this, JTAPI 1.3 added "meta" events that are used to mark
the start and end of batches of call events.</font></font></blockquote>
</div>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote><font color="#000000"><font size=-1>Unfortunately, in the 1.3
spec. the Listener pattern has only been applied to the core package, not
sub-packages such as callcontrol (which we use).&nbsp; This leaves us with
three different situations in the three JTAPI packages we support;</font></font>
<ol>
<li>
<font color="#000000"><font size=-1>In core, <tt>Observers</tt> are deprecated
in favour of <tt>Listeners</tt></font></font></li>

<li>
<font color="#000000"><font size=-1>In callcontrol <tt>Observers</tt> are
the only model</font></font></li>

<li>
<font color="#000000"><font size=-1>In media (which underwent its own drastic
change in 1.3) <tt>Listeners</tt> exist for the new <tt>MediaService</tt>
and <tt>Observers</tt> for the old <tt>MediaTerminalConnection</tt>.</font></font></li>
</ol>
</blockquote>
</div>

<blockquote>
<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%"><font color="#000000"><font size=-1>In
early iterations of the Generic JTAPI Framework, we relied on the TelephonyProvider
sending events off to one single RawObserver.update() method.&nbsp; From
this point the Generic Framework:</font></font></div>
</blockquote>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote>
<ol>
<li>
<font color="#000000"><font size=-1>Placed the events in a queue to be
handled by a separate thread (freeing the TelephonyProvider)</font></font></li>

<li>
<font color="#000000"><font size=-1>Asked the event to attach itself to
the Generic Framework objects.</font></font></li>

<li>
<font color="#000000"><font size=-1>Asked the event to send itself to the
appropriate Observers and / or Listeners.</font></font></li>
</ol>
</blockquote>
</div>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote><font color="#000000"><font size=-1>The problem with this architecture
was that it:</font></font>
<ol>
<li>
<font color="#000000"><font size=-1>Is very weakly typed.&nbsp; All selector
and id information is encapsulated in a passed parameters.&nbsp; No compile-time
checking for invalid types is performed.</font></font></li>

<li>
<font color="#000000"><font size=-1>Imposes the JTAPI event set and, consequently,
the JTAPI state machine, on the TelephonyProvider.</font></font></li>

<li>
<font color="#000000"><font size=-1>Is complex to use:</font></font></li>
</ol>
</blockquote>
</div>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote>
<blockquote>
<ul>
<li>
<font color="#000000"><font size=-1>Determine the appropriate JTAPI event
transition</font></font></li>

<li>
<font color="#000000"><font size=-1>Create an instance of the appropriate
event</font></font></li>

<li>
<font color="#000000"><font size=-1>Populate the event with the right information</font></font></li>

<li>
<font color="#000000"><font size=-1>Toss the event into an event queue</font></font></li>
</ul>
</blockquote>
</blockquote>
</div>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote><font color="#000000"><font size=-1>As well, the support for
callcontrol events was not well mapped out.</font></font></blockquote>
</div>

<blockquote>
<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%"><font color="#000000"><font size=-1>Consequently,
in version 0.6 of the framework, the callback mechanism was overhauled
to replace the RawObserver with a TelephonyListener.&nbsp; This interface
defines all the known object transitions that the Generic Framework is
able to handle.&nbsp; Instead of "<tt>update(BaseEv ev)"</tt>, the new
interface is more strongly and explicitly typed in its method names and
only requires basic types in its callback parameters.&nbsp; The telephony
provider no longer has to build an appropriate event object and pass it
to a generic "update" method.</font></font>
<p><font color="#000000"><font size=-1>Examples of TelephonyListener method
signatures include:</font></font></div>
</blockquote>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote>
<blockquote>
<pre><font color="#000000"><font size=-1>TelephonyListener.callActive(CallId call, int cause);</font></font></pre>

<pre><font color="#000000"><font size=-1>TelephonyListener.connectionAlerting(CallId call, String addressName, int cause);</font></font></pre>

<pre><font color="#000000"><font size=-1>TelephonyListener.terminalConnectionHeld(CallId call, String addressName, String terminalName, int cause);</font></font></pre>

<pre><font color="#000000"><font size=-1>etc.</font></font></pre>
</blockquote>
</blockquote>
</div>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote><font color="#000000"><font size=-1>When the Generic Framework
receives one of these messages it:</font></font>
<ol>
<li>
<font color="#000000"><font size=-1>The framework looks up or lazily creates
the loosely referenced JTAPI object.&nbsp; <i>Note: "<tt>drop</tt>" or
"<tt>disconnect</tt>" are not lazily created but abandoned if they don't
exist.</i></font></font></li>

<li>
<font color="#000000"><font size=-1>The framework creates an appropriate
runnable block and place it in a queue for subsequent processing, letting
the TelephonyProvider continue</font></font></li>

<li>
<font color="#000000"><font size=-1>The runnable block asks the object
to change its state</font></font></li>

<li>
<font color="#000000"><font size=-1>The object checks the state change
for validity (invalid state change means a bug and may be logged or thrown
in a RuntimeException).</font></font></li>

<li>
<font color="#000000"><font size=-1>The object changes its state</font></font></li>

<li>
<font color="#000000"><font size=-1>The object sends an appropriate JTAPI
event off to its <tt>Observers</tt> and/or <tt>Listeners</tt>.</font></font></li>
</ol>
</blockquote>
</div>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote><font color="#000000"><font size=-1>This provides for a much
simpler handling of event notification in a TelephonyProvider.&nbsp; Now,
instead of creating a complex JTAPI event and firing it off to a weakly
typed method, the TelephonyProvider needs to just call the appropriate
TelephonyListener method with a couple of identification parameters.</font></font></blockquote>
</div>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote><font size=-1><font color="#000000">Note: Since the </font>telephony<font color="#000000">
provider is managed through a low-level (RISC-ish) interface, we do not
always have information on the context of a particular state change event.&nbsp;
For this reason MetaEvents are currently not well supported.&nbsp; The
exception to the is the provision of MetaIds during the generation of "snapshot"
events to reflect the current state of Framework JTAPI objects.</font></font></blockquote>
</div>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote><font size=-1><font color="#000000">Despite the intention to
further decouple the </font>telephony<font color="#000000"> provider from
the JTAPI state machine, there is none-the-less a high correlation between
the two event sets.&nbsp; Considering the shared telephony domain they
both describe, this is not surprising.&nbsp; The differences between the
two event sets are:</font></font></blockquote>
</div>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote>
<ul>
<li>
<font color="#000000"><font size=-1>Unknown is not provided</font></font></li>

<li>
<font color="#000000"><font size=-1>ListenerEnded is not, of course, provided</font></font></li>

<li>
<font color="#000000"><font size=-1>Connection created is not provided,
but rather implied</font></font></li>

<li>
<font color="#000000"><font size=-1>Address and Terminal, with no state,
have no methods</font></font></li>

<li>
<font color="#000000"><font size=-1>There are TelephonyListener callcontrolTerminalConnection
listener methods even though this does not yet have Listeners, but only
Observers.</font></font></li>

<li>
<font color="#000000"><font size=-1>terminalConnectionActive() is replaced
by more explicit callcontrol methods (Talking and Held)</font></font></li>

<li>
<font color="#000000"><font size=-1>terminalConnectionPassive() (and it's
subtypes Bridged and InUse) are not supported</font></font></li>
</ul>
</blockquote>
</div>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote><font color="#000000"><font size=-1>For now, only the following
events are supported under media:</font></font></blockquote>
</div>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote>
<ul>
<li>
<font color="#000000"><font size=-1>disconnected</font></font></li>

<li>
<font color="#000000"><font size=-1>player pause and resume</font></font></li>

<li>
<font color="#000000"><font size=-1>recorder pause and resume</font></font></li>

<li>
<font color="#000000"><font size=-1>signal detector overflow, pattern matched
and signal detected.</font></font></li>
</ul>
<font size=-1><font color="#000000">Finally, the GenericFramework ensures
that the </font>telephony<font color="#000000"> provider will only be provided
with one TelephonyListener object handle.&nbsp; This simplifies </font>telephony<font color="#000000">
provider creation, since a collection of TelephonyListeners does not have
to be maintained and TelephonyListener events do not have to be dispatched
against such a collection.</font></font>
<h4>
<font color="#000000"><font size=-1>Listener Manager</font></font></h4>

<blockquote><font color="#000000"><font size=-1>The framework provides
a ListenerManager class which is responsible for tracking the lifecycle
of application-registered Observers and Listeners.&nbsp; This is necessary
since the same observer/listener could potentially be associated with a
call in various ways, and yet the JTAPI specification dictates that the
observer/listener should be notified only once.</font></font>
<p><font color="#000000"><font size=-1>In particular, observers/listeners
can be associated with a call by that call visiting an Address or Terminal
on which that observer/listener is registered as waiting for calls.&nbsp;
These observers/listeners are only active on the call while it is at the
Terminal or Address, unless they are explicitly registered against the
call or are registered through another Address or Terminal as well.</font></font>
<p><font color="#000000"><font size=-1>The ListenerManager tracks each
observer or Listener against a call with three pieces of information:</font></font>
<ol>
<li>
<font color="#000000"><font size=-1>The list of Addresses that caused the
observer/listener to be added to the call.</font></font></li>

<li>
<font color="#000000"><font size=-1>The list of Terminals that cause the
observer/listener to be added to the call.</font></font></li>

<li>
<font color="#000000"><font size=-1>A flag to note that the observer/listener
was directly added to the call.</font></font></li>
</ol>
<font color="#000000"><font size=-1>Directly added observers or listeners
are only removed from a call explicitly or by the call's death.&nbsp; For
other observers/listeners, though, the ListenerManager checks when they
should be removed.&nbsp; Remember that the same listener/observer can be
attached to the call in multiple ways.&nbsp; So, when a call leaves a Terminal,
for instance, the ListenerManager will:</font></font>
<ol>
<li>
<font color="#000000"><font size=-1>Look for the list of observer/listeners
that were added to the call through that Terminal.</font></font></li>

<li>
<font color="#000000"><font size=-1>For each such observer/listener:</font></font></li>

<ol>
<li>
<font color="#000000"><font size=-1>Ensure that it was not also directly
added to the call</font></font></li>

<li>
<font color="#000000"><font size=-1>Remove the Terminal from the list of
adding Terminals</font></font></li>

<li>
<font color="#000000"><font size=-1>Check if it should now be removed from
the call (not explicitly added, no longer any Terminals or Addresses on
the call that added the observer/listener)</font></font></li>
</ol>
</ol>
<font size=-1><font color="#000000">Thus, the ListenerManager manages the
complex lifecyle requirements of JTAPI Observers and Listeners and isolates
this behaviour away from the </font>telephony<font color="#000000"> provider.</font></font></blockquote>

<h4>
<font color="#000000"><font size=-1>Reporting</font></font></h4>

<blockquote><font size=-1>For a large system, reporting all call events
would bog the JTAPI framework down with callback events, cause needless
object creation and chew up possibly expensive monitor resources.&nbsp;
Since most of these events may never be reported to an application, the
Generic JTAPI framework allows for the "throttling" of telephony provider
events if the TelephonyProvider indicates throttling support through the
"getCapabilities()" return value of "Capabilities.THROTTLE = "t".</font>
<p><font size=-1>Once a CallId is provided to the GenericFramework by the
TelephonyProvider, the TelephonyProvider is contracted to continue providing
state change events for this call or its components (Connections and TerminalConnections)
until such time as the call dies or the Generic Framework turns off Call
reporting through the sending of a "stopReportingCall(CallId call)" message.&nbsp;
In addition to creating a Call and asking for all calls at an Address or
Terminal, the Generic Framework may request future reporting of calls through:</font>
<ul>
<li>
<font size=-1>"<tt>reportCallsOnAddress(String address, boolean report)</tt>",
indicating that the indicated address should have events reported on all
calls associated with the address now or in the future.</font></li>

<li>
<font size=-1>"<tt>reportCallsOnTerminal(String terminal, boolean report)</tt>",
indicating that the indicated terminal should have events reported on all
calls associated with the terminal now or in the future.</font></li>
</ul>
<font size=-1>The "report" parameter turns reporting on or off.&nbsp; Note
that when reporting is first requested, the telephony provider should send
"Snapshot" events up to the framework detailing the current state of a
call and its connections and terminal connections.</font>
<p><font size=-1>For some telephony providers, the extra complexity of
event throttling is not justified, since they manage so few lines.&nbsp;
In that case, the telephony provider can tell the framework that it will
report all events, allowing the framework to not bother sending the "report"
requests.&nbsp; See the <a href="#Tuning">Tuning</a> section for more details.</font></blockquote>

<h4>
<font size=-1>TelephonyListener Threading</font></h4>

<blockquote><font size=-1>&nbsp;TelephonyListener "state" callbacks may
cause problems for TelephonyProvider implimentations if in that they hand
off control of a thread to an external entity (the Generic JTAPI Framework).&nbsp;
For near real-time systems, like telephony systems, such external processing
may cause problems.</font>
<p><font size=-1>One option is to create a event handling pool in the Generic
Framework that queues up event information for later processing and returns
almost immediately to the TelephonyProvider.&nbsp; This solves the "callback"
non-deterministic latency problem, but introduces its own.&nbsp; JTAPI
specifies the post-conditions that the objects will be in at the completion
of a method call.&nbsp; For instance, a transfer method does not return
until the call has been transferred. This sort of synchronous paradigm
is the most common usage paradigm in JTAPI, although it is sometimes broken,
particularly in the media package.</font>
<p><font size=-1>The Generic JTAPI Framework sort-of obeys this paradigm.&nbsp;
The "transfer" method does not return until the call has been transferred.&nbsp;
That does not mean, however, that the raw TelephonyProvider has necessarily
updated the Generic JTAPI object model yet, since we don't know how long
the TelephonyListener processing queue is at any given time.</font>
<p><font size=-1>As an example, the Generic Framework is asked to connect
a call to a remote number.&nbsp; It makes a "connect" call down to the
plugged-in TelephonyProvider which connects the call, issuing the appropriate
events back to the TelephonyListener, and then returns the "connect" method.&nbsp;
A race condition now exists over whether the asynchronous state update
events will actually update the object model before the Generic Framework
tells the calling application that the connect has succeeded.&nbsp; If
the update events lose, then there is a chance that the application may
call another method (i.e. getConnections()) which will return unexpected
results such as a "null" Connection set or "InvalidStateException" indicating
that the call is IDLE.</font>
<p><font size=-1>Several options exist for ensuring that the command does
not return until all of its generated asynchronous events have been processed,
but they all have there own problems or complexities.&nbsp; In the end,
it was decided to return TelephonyListener callback processing to "in-thread"
and constrain the actions that the Generic Framework will perform to:</font>
<ul>
<li>
<font size=-1>Creating any new required call domain objects</font></li>

<li>
<font size=-1>Updating the state of one call object</font></li>
</ul>
<font size=-1>By limiting the processing of TelephonyProvider state events
to these actions, we can provide some guarentee of timely return from an
event callback while ensuring deterministic state machine changes in the
Generic Framework.&nbsp; In particular, the callback does not directly
create application-level JTAPI Listener or Observer events.&nbsp; These
are delegated off to a client-dispatch thread for asynchronous processing.</font></blockquote>
</blockquote>
</div>

<blockquote>
<h3>
<a NAME="Exception Management"></a>7.5 Exception Management</h3>
</blockquote>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote><font color="#000000"><font size=-1>Seven events may be thrown
by sub-provider calls, one of which is a Runtime event:</font></font></blockquote>
</div>

<br>&nbsp;
<table BORDER CELLSPACING=0 CELLPADDING=4 WIDTH="100%" BORDERCOLOR="#000000" >
<caption><b>Command to Exception Mapping</b></caption>

<tr VALIGN=TOP>
<th WIDTH="12%">Primitive Call</th>

<th WIDTH="12%">InvalidArgumentException</th>

<th WIDTH="12%">InvalidpartyException</th>

<th WIDTH="12%">InvalidStateException</th>

<th WIDTH="12%">MethodNotSupportedException</th>

<th WIDTH="12%">PriveledgeViolationException</th>

<th WIDTH="12%">ResourceUnavailableException</th>

<th WIDTH="13%">PlatformException (Runtime)</th>

<th>MediaResourceException</th>
</tr>

<tr VALIGN=TOP>
<td WIDTH="12%">Connect</td>

<td WIDTH="12%">X</td>

<td WIDTH="12%">X</td>

<td WIDTH="12%">X</td>

<td WIDTH="12%">X</td>

<td WIDTH="12%">X</td>

<td WIDTH="12%">X</td>

<td WIDTH="13%">x</td>

<td></td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="12%">Answer</td>

<td WIDTH="12%"></td>

<td WIDTH="12%"></td>

<td WIDTH="12%">X</td>

<td WIDTH="12%">X</td>

<td WIDTH="12%">X</td>

<td WIDTH="12%">X</td>

<td WIDTH="13%">x</td>

<td></td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="12%">Hold</td>

<td WIDTH="12%"></td>

<td WIDTH="12%"></td>

<td WIDTH="12%">X</td>

<td WIDTH="12%">X</td>

<td WIDTH="12%">X</td>

<td WIDTH="12%">X</td>

<td WIDTH="13%">x</td>

<td></td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="12%">Unhold</td>

<td WIDTH="12%"></td>

<td WIDTH="12%"></td>

<td WIDTH="12%">X</td>

<td WIDTH="12%">X</td>

<td WIDTH="12%">X</td>

<td WIDTH="12%">X</td>

<td WIDTH="13%">x</td>

<td></td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="12%">Join</td>

<td WIDTH="12%"></td>

<td WIDTH="12%">X</td>

<td WIDTH="12%">X</td>

<td WIDTH="12%">X</td>

<td WIDTH="12%">X</td>

<td WIDTH="12%">X</td>

<td WIDTH="13%">x</td>

<td></td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="12%">Release</td>

<td WIDTH="12%"></td>

<td WIDTH="12%"></td>

<td WIDTH="12%">X</td>

<td WIDTH="12%">X</td>

<td WIDTH="12%">X</td>

<td WIDTH="12%">X</td>

<td WIDTH="13%">x</td>

<td></td>
</tr>

<tr>
<td>(media)
<br>play,
<br>record,
<br>sendSignals,
<br>retrieveSignals</td>

<td></td>

<td></td>

<td></td>

<td></td>

<td></td>

<td></td>

<td></td>

<td>X</td>
</tr>
</table>

<blockquote>
<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%"><font color="#000000"><font size=-1>We
note:</font></font></div>

<ul>
<li STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<font color="#000000"><font size=-1>We have not listed initialization calls
here. It throws a ProviderUnavailable exception</font></font></li>

<li STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<font color="#000000"><font size=-1>PlatformException may be thrown by
any method. Being a runtime exception, it indicates a dramatic unpredictable
failure and should be handled at a top level.</font></font></li>

<li STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<font color="#000000"><font size=-1>Four exceptions are always thrown in
non-media commands.</font></font></li>

<li STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<font color="#000000"><font size=-1>Only InvalidStateException takes a
JTAPI object as part of its state.</font></font></li>

<li STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<font color="#000000"><font size=-1>Media commands return a MediaResourceException,
which wraps an instance of one of the JTAPI media event interfaces.</font></font></li>
</ul>
</blockquote>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote><font color="#000000"><font size=-1>From this analysis, it
was decided that the JTAPI exception set would be extended unchanged down
to the TelephonyProvider, with the caveat that InvalidStateException is
replaced by a RawStateException. This ensures that the sub-provider has
the maximum exception throwing capabilities required.</font></font></blockquote>
</div>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote><font color="#000000"><font size=-1>RawStateException is actually
a subclass of InvalidStateException that replaces the JTAPI object handle
with the primitive reference types described earlier. In the Generic JTAPI
Framework, this exception is caught and, much like the old event handling
technique, passed a visitor that allows the primitive types to be mapped
into the appropriate JTAPI object for an InvalidStateException exception.</font></font></blockquote>
</div>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote><font size=-1><font color="#000000">The one problem with this
design is that it implies that the sub-provider be able to map its state
machine to the JTAPI state machine. An alternative is to assume that the
JTAPI objects with catch invalid state problems themselves, but since their
may be some race conditions between state event notification and application
requests, this cannot be guaranteed. Proper creation of both exceptions
and events dictates that similar state machines be used by all </font>telephony<font color="#000000">-providers,
so it may as well be the JTAPI state machines.</font></font></blockquote>
</div>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote><font size=-1><font color="#000000">The situation for Media
resources is somewhat simpler. The JTAPI media methods only define a single
MediaResourceException, which simply wraps up one of the media events that
describes the problem.&nbsp; The "T</font>elephony<font color="#000000">
Provider Interface" provides four media events for this purpose.&nbsp;
As with RawStateExceptions, the framework must ensure that the wrapped
event is properly hooked to the appropriate Generic JTAPI Framework media
object before it is re-thrown to the calling client application.</font></font></blockquote>
</div>

<blockquote>
<h3>
<a NAME="Remote Support"></a>7.6 Remote Support</h3>
</blockquote>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote><font color="#000000"><font size=-1>Because the Generic JTAPI
Framework is decoupled from the low-level TelephonyProviders, it is possible
to interject a remote proxy layer between the two that allows them to optionally
be distributed. This has the advantages over building distribution into
the architecture in that:</font></font></blockquote>
</div>

<ul>
<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote>
<li>
<font color="#000000"><font size=-1>The cost of distribution (serialization,
remote exception handling) is only incurred when it is needed.</font></font></li>

<li>
<font color="#000000"><font size=-1>Different remote proxies can be built,
providing different time/space/reliability/maintainability tradeoffs.</font></font></li>
</blockquote>
</div>
</ul>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote><font color="#000000"><font size=-1>The current architecture
supports the interjection of a remote proxy layer. Implementations, such
as RMI, that support object and exception serialization can be easily built.
Remote exceptions which indicate communication failure must be presented
to the Generic JTAPI Layer in a meaningful way. The suggested architecture
is to silently consume any event callback remote exceptions and to throw
a JTAPI Runtime PlatformException for calls initiated from the Generic
JTAPI Framework. This can be justified since usually once a remote exception
occurs, the remote link is broken and it is impossible to easily recover.</font></font></blockquote>
</div>

<blockquote>
<h3>
<a NAME="Multiplexor Support"></a>7.6.B Multiplexor Support</h3>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%"><font color="#000000"><font size=-1>One
of the advantages of the pluggable architecture is that it decouples the
components and allows them to be easily recombined in new configurations.
On such configuration is to allow multiple low-level providers to be multiplexed
together and appear as a single low-level provider to the Generic JTAPI
Framework. This would allow for easy scaling of a system, as well as the
combining of different low-level provider types into one logical JTAPI
provider, say a Dialogic and a Linkon board on the same machine.</font></font></div>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%"><font color="#000000"><font size=-1>The
current architecture supports this by having all CallId and address names
generated by the low-level provider. The multiplexor bridge catches this
information and builds an association map. Note that this is the reason
that the TelephonyProvider interface requires an address name for the reservation
of a CallId; the address name is required to look up which low-level delegate
to forward the reservation request to. When when the Generic JTAPI Framework
wishes to perform an action, the action's parameters can be checked in
the maps to determine which low-level provider to forward the command to.
When the Generic JTAPI Framework releases a CallId, the multiplexor releases
the CallId from the mapping table.</font></font></div>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%"><font color="#000000"><font size=-1>Two
problems arise with such a multiplexor:</font></font>
<ol>
<li>
<font color="#000000"><font size=-1>Multiplexed low-level providers should
not have overlapping address or terminal name spaces (this is a logical
restriction).</font></font></li>

<br><font color="#000000"><font size=-1>If a call is made from one low-level
provider to a number that gets forwarded to another low-level provider
(i.e. Through a 1-800 mapping table), the multiplexor may not be able to
determine that the incoming call on the second low-level provider is the
same logical call as the outgoing call on the first logical provider. Even
if the address names can be matched up, the two low-level providers will
be reporting different CallIds. It may be possible to detect this and create
a wrapper id, but this will be difficult.</font></font></ol>
</div>

<h3>
<a NAME="Call Transfer/Conference"></a>7.7 Call Transfer/Conference</h3>
</blockquote>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote><font color="#000000"><font size=-1>Transfer and Conference,
while conceptually different, can really be implemented with very similar
telephony actions. A transfer can be thought of as simply a conference
from which the conference creator has been disconnected. Since JTAPI is
a third-party call control API, it needs to know which party in a call
is going to perform the transfer. Similarly with Conference, it is possible
that two parties are already members of both calls and so it might not
be clear which party should create the conference. JTAPI solves this with
the concept of a Transfer and Conference Controller which may be assigned
to a call.</font></font></blockquote>
</div>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote><font color="#000000"><font size=-1>Within the Generic JTAPI
Framework, transfer is simply seen as the combination of joining a call
and then dropping the join-creator party from the call. For unattended
transfer, the join and drop are performed on a call that is still connecting.</font></font></blockquote>
</div>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote><font color="#000000"><font size=-1>The following table shows
how the Generic JTAPI Framework maps JTAPI transfer and conference actions
to the TelephonyProvider interface methods. It also notes what the usage
status of the relative controller is.</font></font></blockquote>
</div>

<br>&nbsp;
<table BORDER CELLSPACING=0 CELLPADDING=4 BORDERCOLOR="#000000" STYLE="page-break-inside: avoid" >
<caption><b>Transfer/Conference mapping to "primitive" commands</b></caption>

<tr VALIGN=TOP>
<th WIDTH="20%"></th>

<th WIDTH="20%">connect()</th>

<th WIDTH="20%">join()</th>

<th WIDTH="20%">release()</th>

<th>hold()</th>

<th WIDTH="20%">Controller</th>
</tr>

<tr VALIGN=TOP>
<td WIDTH="20%">Consult(TerminalConnection)</td>

<td COLSPAN="5">
<center><i>Not supported</i></center>
</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="20%">Consult(digits)</td>

<td WIDTH="20%">X</td>

<td WIDTH="20%"></td>

<td WIDTH="20%"></td>

<td>X</td>

<td WIDTH="20%">
<center>Sets both controllers</center>
</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="20%">Conference(Call)</td>

<td WIDTH="20%"></td>

<td WIDTH="20%">X</td>

<td WIDTH="20%"></td>

<td></td>

<td WIDTH="20%">
<center>Optionally used if available</center>
</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="20%">Transfer(Call)</td>

<td WIDTH="20%"></td>

<td WIDTH="20%">X</td>

<td WIDTH="20%">X</td>

<td></td>

<td WIDTH="20%">
<center>Optionally used if available</center>
</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="20%">Transfer(digits)</td>

<td WIDTH="20%">X</td>

<td WIDTH="20%">X</td>

<td WIDTH="20%">X</td>

<td>X</td>

<td WIDTH="20%">
<center>Required</center>
</td>
</tr>
</table>

<blockquote>
<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%"><font color="#000000"><font size=-1>Note
that when the controller is optional, the Generic JTAPI Framework will
try to assign a controller to the conference or transfer itself by looking
for a Terminal that is part of both calls. The unattended transfer requires
that the TransferController be set, since otherwise it has no idea which
party on the call should perform the transfer (and therefore leave the
call). At this time consulting a TerminalConnection (adding a new Connection
to an active call) is not supported.</font></font></div>

<h3>
<a NAME="Media Support"></a>7.8 Media Support</h3>
</blockquote>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote><font color="#000000"><font size=-1>As of JTAPI 1.3, the JTAPI
team changed their media architecture to more closely match the ECTF framework
model.&nbsp; What is interesting about this is that in a way it now parallels
the U|Builder.&nbsp; Essentially they have dropped (well, deprecated) the
straight subclassing of JTAPI objects and moved to an architecture which
defines:</font></font></blockquote>

<blockquote>
<ul>
<li>
<font color="#000000"><font size=-1><b>MediaService</b>.&nbsp; This encapsulates
a group of resources and can act on a call.&nbsp; The highlighted way this
is presented is that a System Call Router (ACD, for instance) would detect
a call type and forward it to a MediaService registered with a certain
name.&nbsp; At this point, the MediaService would have its resources allocated
and would wake-up to process the call.&nbsp; Variations include RunnableMediaService
which can sit in a pool and be pulled out, configured and run.&nbsp; For
our usage, we could create a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MediaService
that binds to a Call or MediaTerminal directly instead of being managed
by some service framework (which JTAPI Media does not define).&nbsp; A
well architected MediaService releases its resources when it loses control
of a call, reducing the chance that an application can somehow inadvertently
tie up resources.</font></font></li>

<li>
<font color="#000000"><font size=-1><b>MediaGroup</b>.&nbsp; This is a
low-level holder of media access on a terminal that may be passed between
different MediaServices.&nbsp; A MediaService can be subclassed to provide
certain behaviour and pass on its held MediaGroup to another MediaService.&nbsp;
In essence the MediaGroup acts as the resource holder that is separated
from the "services" and may be passed between services.</font></font></li>

<li>
<font color="#000000"><font size=-1><b>Resources</b>.&nbsp; These are the
basic media manipulators.&nbsp; Sub-interfaces include Player, Recorder,
SignalGenerator and SignalDetector.&nbsp; Fax is promised in the future.</font></font></li>

<li>
<font color="#000000"><font size=-1><b>MediaTerminal</b>.&nbsp; This is
a marker interface that denotes terminals that a Resource can interact
with.</font></font></li>
</ul>
</blockquote>

<blockquote><font color="#000000"><font size=-1>There are other things
as well, such as RTCs (Run Time Controls), Symbols and Media Stream Containers
that we will have to deal with.</font></font>
<p><font color="#000000"><font size=-1>The biggest two problems with the
current specification of the media package are:</font></font>
<ol>
<li>
<font size=-1>The 1.3 version of the Media service provides a reference
"<tt>B<font color="#000000">asicMediaService</font></tt><font color="#000000">"
whose purpose it to act as a default and extendable media service manager.&nbsp;
Unfortunately, in version 1.3 of the media specification, this is hard-coded
as extending NullMediaService.&nbsp; The state intention is that applications
can subclass this and use it.&nbsp; But with NullMediaService as a parent,
it is inoperable.&nbsp; The documentation indicates that "<tt>actual implementations
may extend some other vendor specific class</tt>", but this is poor way
of providing a framework.&nbsp; Instead of implementing the API, we have
to replace it.&nbsp; The JTAPI Provider and Peer take us 90% of the way
there, allow us to plug in different implementations on the fly.&nbsp;
Then suddenly we have to install on the classpath the right version of
the base JTAPI classes support a particular board's media vendor.&nbsp;
To support two different Media vendors would require that applications
use tricks involving custom classloaders.</font></font></li>

<br>&nbsp;
<p>&nbsp;
<br>&nbsp;
<br>&nbsp;
<p><font color="#000000"><font size=-1>The Generic JTAPI Framework replaces
BasicMediaService with GenericMediaService which has the same semantics
and interfaces but is not a subclass of NullMediaService.</font></font>
<li>
<font color="#000000"><font size=-1>RTCs and Symbols.&nbsp; The JTAPI Media
Service follows the ECTF pattern of using immutable Symbol objects to send
media "trigger" and "action" information to the media resources.&nbsp;
But these are also not serializable, so the information cannot be easily
sent to a remote media resource.&nbsp; This seems to be a by-product of
earlier ECTF implementations of Symbol which left it as both a information
holder and a type registry.&nbsp; We have contacted the ECTF and provided
them with examples of serializable Symbol and RTC classes and they have
indicated that this will be fixed in JTAPI 2.0.</font></font></li>

<br>&nbsp;
<p>&nbsp;
<br>&nbsp;
<br>&nbsp;
<p><font color="#000000"><font size=-1>In the meantime, the Generic JTAPI
framework provides SymbolHolder and RTCHolder utility classes that allow
for the serialization and recreation of Symbol information.</font></font></ol>

<h4>
<font color="#000000"><font size=-1>Design Options</font></font></h4>

<ol><font color="#000000"><font size=-1>The initial TPI media design set
play, record, detect and generate methods against calls.&nbsp; The JTAPI
Media, however, specifies Terminals as the access point (this is a change
from 1.2 which used TerminalConnection).&nbsp; The implication is that
whatever call is active on the terminal will be connected to the media
sockets.&nbsp; One issue is how to handle MediaTerminals:</font></font></ol>
</blockquote>

<ol>
<ol>
<ol>
<li>
<font size=-1><font color="#000000">One option it to force a call to be
conferenced with another Terminal that supports MediaTerminal, if the call
does not presently possess any media-capable Terminals. This maps to the
architectural design of the ECTF framework.&nbsp; On the other hand, it
may require a lot of connection management.&nbsp; A side-effect is that
the framework must interrogate the </font>telephony<font color="#000000">
provider for media support on all terminals.</font></font></li>

<li>
<font color="#000000"><font size=-1>Another option is to make all Terminals
implement MediaTerminal.&nbsp; However this now implies that all TelephonyProviders
must support media.&nbsp; Note that JTAPI Media breaks with the JTAPI paradigm
and does not support "capabilities"; instead it uses design by contract
(if it implements an interface, it can do all the interface's actions).</font></font></li>
</ol>
<font size=-1><font color="#000000">Since we don't know the media constraints
of all possible </font>telephony<font color="#000000"> provider implementations,
we must opt for the first, more conservative, design.</font></font>
<p><font size=-1><font color="#000000">Unlike other JTAPI packages, media
does not use capabilities to determine what is and is not supported. With
JTAPI media, a contract paradigm is applied. If a Terminal implements MediaTerminal
and the media resources can be acquired (subject, of course, to resource
availability) then all media capabilities are guaranteed to be available.&nbsp;
During initialization the framework queries the </font>telephony<font color="#000000">
provider using the "<tt>isMediaTerminal()</tt>" query method that determines
if a given terminal name identifies a media terminal. This is used during
the initialization of the framework to dynamically determine if an instance
of FreeTerminal or FreeMediaTerminal needs to be instantiated for a particular
known and managed terminal name.&nbsp; Under "<a href="#Capabilities">Capabilities</a>",
we will discuss the algorithm used to determine media capabilities on Terminals.</font></font></ol>
</ol>
</div>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote><font color="#000000"><font size=-1>Terminals which implement
the "MediaTerminal" marker interface by contract support media and all
media resources.</font></font>
<br><font size=-1><font color="#000000">&nbsp;Once a Terminal is identified
that supports media services, it can be bound to a MediaService. Within
the Framework this binding results in the MediaService sending a command
to the </font>telephony<font color="#000000"> provider to allocate low-level
media resources to that terminal name. The bound resources are low-level
equivalents to the logical resources grouped together in the MediaService.
When the MediaService is unbound from a terminal, the </font>telephony<font color="#000000">
provider is told to de-allocate the associated low-level media resources.</font></font></blockquote>
</div>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote><font color="#000000"><font size=-1>Currently the four media
resources that may be supported are:</font></font></blockquote>
</div>

<ul>
<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote><font color="#000000"><font size=-1><u>Player</u>. For playing
a set of audio streams into the active call associated with the MediaTerminal.
The audio streams are passed not by data but by an abstract stream id.
For the purposed of the Generic JTAPI architecture, these ids will either
be file names or URL strings.</font></font></blockquote>
</div>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote><font color="#000000"><font size=-1><u>Recorder</u>. For recording
the audio on the active call at the associated MediaTerminal. The audio
is recorded to the file or URL referenced by a passed stream id.</font></font></blockquote>
</div>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote><font color="#000000"><font size=-1><u>SignalDetector</u>.
This is a DTMF receiver that collects all DTMF signals into a buffer and
then can be polled for the collected signals. Note that signal detection
is not turned off and on. To collect signals from only a certain point
in time, the buffer must first be emptied.</font></font></blockquote>
</div>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote><font color="#000000"><font size=-1><u>SignalGenerator</u>.
This causes a series of DTMF signals to be played on the call that is active
at the MediaTerminal. While in JTAPI this can be called with either a String
or a set of Symbols, the current architecture will coalesce both of these
into a single TelephonyProvider calls that delivers a set of Symbols to
the low-level DTMF generator.</font></font></blockquote>
</div>
</ul>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote><font color="#000000"><font size=-1>In addition to the initialization
query method, two allocation methods and the four implied methods above,
the TelephonyProvider also supports the MediaService stop() method, which
basically broadcasts a "stop any current actions" command to all low-level
media resources allocation to the terminal.</font></font></blockquote>
</div>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote><font color="#000000"><font size=-1>Within the basic media
calls are some other more complex concepts. One is the support for a dictionary
of optional service parameters. This may be confusing, since both UserDictionary
and Parameters dictionaries are supported.&nbsp; The documentation for
1.3 Media is not very clear in this matter, but careful reading reveals
that the UserDictionary is a way for an application object using a MediaService
to associate application information with a MediaService's bound MediaGroup.&nbsp;
The Media package allows a MediaGroup to be passed between various MediaServices.&nbsp;
So, for instance, an application may create several "beans" for handling
calls and tag call infomation (User's account number and priority) into
a MediaGroup's UserDictionary.&nbsp; As the MediaGroup is passed from one
Media Service (menu) to another (record audio) this information can be
passed along.&nbsp; It is not used my the low-level media but by the controlling
application-level "beans".</font></font>
<p><font color="#000000"><font size=-1>Parameters, on the other hand, are
basically resource configuration holders that the ECTF architects did not
want to place into strongly typed initialization parameters or classes,
probably in order to reduce interface complexity and provide maximum flexibility.&nbsp;
Generally the keys and values in the Parameters dictionary are "p_" and
"ev_" named Symbols.&nbsp; The problem with this design is that while there
is an agreed "Ontology" specifying the meaning of name-value pairs in the
optional parameter dictionary (Defined in various SymbolConstant classes),
the name-space is relatively large, making it either very difficult to
support all parameters or hard to indicate which are supported.&nbsp; None-the-less,
the current Generic JTAPI Framework architecture does allow for these parameter
holders to be passed on to the low-level resources.&nbsp; Examples of a
possible Parameters entries that may be set for a MediaService include:</font></font>
<blockquote>&nbsp;
<table BORDER >
<tr>
<td><tt>p_EnabledEvents -> ev_SignalDetected</tt></td>

<td>This indicates that the SignalDetector should send events for each
detected signal, on top of any collection in the SignalBuffer.</td>
</tr>
</table>
</blockquote>
</blockquote>
</div>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote><font color="#000000"><font size=-1>Finally, the ECTF Media
architecture defines Runtime Controls. These are symbol pairs that define
how a media resource will respond when certain events occur. The alternative
to such a capability is to have the MediaResource listening for events
and then sending response commands back to the low-level media resource.
The problem with this more traditional approach is one of timing, latency
and user perception. If, for instance, a user is using an IVR system that
offers a menu of options, the user expects the option menu to stop playing
when they select an option (push a button). If the option menu continues
to play, the user may believe that their command was not received and push
the button again. Then the application catches up and sees multiple received
signals and places the user into an unexpected sub-state.</font></font></blockquote>
</div>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote><font color="#000000"><font size=-1>To support Runtime Commands,
the TelephonyProvider interface allows RTCs to be passed down to a low-level
media resource. It also supports the JTAPI media capability to trigger
RTCs in resources by sending "pseudo-events" to the low-level resources
through the "triggerRTC()" method.&nbsp; An example of this might be the
sending of the Symbol "PlayerConstants.rtca_Stop" to tell the media implementation
to stop playing any current output stream.&nbsp; Again, the possible "rtca_"
action Symbol space is very large, leading to difficulties in providing
consistent or full implementations.</font></font>
<h4>
<font color="#000000"><font size=-1>MediaGroup Handoff</font></font></h4>

<blockquote><font size=-1>Basically, ECTF defines a MediaService as a manager
of a collection of media resources (a MediaGroup).&nbsp; A MediaService
may be written that uses this MediaGroup to play recordings and listen
for DTMF, for instance.&nbsp; MediaServices may manually be bound to calls
or they may register with a "manager" for calls with a certain profile.&nbsp;
When they are done with a call, they can either release it totally or tag
it and send it into the pool to be managed by another MediaService.&nbsp;
Furthermore, the MediaGroup travels with the call and holds onto call information
which can be accessed by each MediaService as it gets control of the call,
using the UserDictionary.&nbsp; This functionality has built into the Generic
JTAPI Framework.</font>
<p><font size=-1>So, for instance, the following is currently possible:</font>
<ol>
<li>
<font size=-1>An application starts up and creates a bunch of MediaService
instances and registers them with the media manager for certain types of
calls (initial, authentication, email play, stock reporting, ...).</font></li>

<li>
<font size=-1>The application creates a pool of initial MediaServices.</font></li>

<li>
<font size=-1>The application registers Terminal listeners for each incoming
line.</font></li>

<li>
<font size=-1>When a call arrives on a Terminal, the application's listener
callback function binds the call to an "initial" MediaService from the
pool.</font></li>

<li>
<font size=-1>The MediaService plays an initial greeting and looks at the
incoming caller id.</font></li>

<li>
<font size=-1>The MediaService then releases it to the appropriately registered
service (i.e. authentication).</font></li>

<li>
<font size=-1>The manager finds an idle authentication MediaService and
hands the initial MediaService's MediaGroup off to this waiting MediaService.</font></li>

<li>
<font size=-1>The manager starts the authentication MediaService.</font></li>

<li>
<font size=-1>The initial MediaService may now be returned to the pool.</font></li>
</ol>
<font size=-1>This has been implemented in the Generic JTAPI framework
using dictionaries of:</font>
<ul>
<li>
<font size=-1>terminal to MediaService bindings, so we can route low-level
media events to the right MediaService</font></li>

<li>
<font size=-1>MediaService to waiting service name, so MediaServices can
sit waiting for a request for one of them by a certain name.</font></li>

<li>
<font size=-1>MediaGroup to waiting name.&nbsp; This is for calls that
are being handed off but do not yet have a destination MediaService.&nbsp;
They sit in this queue for X milliseconds to see if a new MediaService
will get dropped back into the manager ready to handle them.&nbsp; If no
MediaService shows up, eventually the "bindToServiceName()" call from whence
they came will return with a MediaBindException.</font></li>
</ul>
</blockquote>
</blockquote>
</div>

<blockquote>
<h3>
<a NAME="Deprecated 1.2 Media Support"></a>7.9 Deprecated 1.2 Media Support</h3>
<font size=-1>Prior to JTAPI 1.3 media was supported through a more orthodox
JTAPI architecture of subclassing one of the basic JTAPI interfaces and
adding new methods to it.&nbsp; In the case of the 1.2 media support, the
subclassed interface was a TerminalConnection.&nbsp; To implement 1.2 media,
then, the JTAPI implementation must add "<tt>javax.telephony.media.MediaTerminalConnection</tt>"
to the set of interfaces implemented by the TerminalConnection class.</font>
<p><font size=-1>In order to support the older media interfaces, an attempt
was made to map the same functionality onto the 1.3 media paradigm.&nbsp;
This allows both the old and new media interfaces to be exposed to the
application layer while not adding new and duplicate media control methods
to the <font color="#000000">TelephonyProvider</font> interface that would
increase the complexity of building a media-capable telephony provider.&nbsp;
Unfortunately, there are some "paradigm" differences between the two media
packages that had to be examined and dealt with.</font>
<h4>
<font size=-1>Resource Allocation</font></h4>

<blockquote>
<h5>
<font size=-1>Problem</font></h5>
<font size=-1>With the 1.3 media classes, MediaServices hold MediaGroups
which are in turn bound to a MediaTerminal.&nbsp; Resources can be added
to a MediaGroup (Player, Recorder, etc.).&nbsp; Depending on the low-level
details, there may be some real cost to associating these resources with
a telephony channel (e.g. tying up a DSP).&nbsp; To support this, the <font color="#000000">TelephonyProvider</font>
interface provides a set of methods that are called from a MediaGroup when
its resource set changes:</font>
<blockquote>
<pre><font size=-1>boolean allocateMedia(String terminal, int type, Dictionary resourceArgs);</font></pre>

<pre><font size=-1>boolean freeMedia(String terminal, int type);</font></pre>
</blockquote>
</blockquote>
</blockquote>

<ol>
<blockquote><font size=-1>The JTAPI 1.2 media's MediaTerminalConnection
does not expose the concept of resources tied to a TerminalConnection.&nbsp;
So for instance, we may write:</font>
<blockquote><tt><font size=-1>if (tc instanceof MediaTerminalConnection)</font></tt>
<br><font size=-1><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
((Me</tt>diaTerminalConnection)tc).generateDTMF("2315112");</font></blockquote>
<font size=-1>So, how does the Framework tell theTelephony Provider to
allocate a signal generator for the terminal?</font>
<br>&nbsp;
<h5>
<font size=-1>Options</font></h5>
<font size=-1>The options seem to be:</font>
<ol>
<li>
<font size=-1>Always allocate all resources to a media terminal during
its life cycle.&nbsp; This could get very expensive and result in ResourceUnavailableExceptions
that are unnecessary.</font></li>

<li>
<font size=-1>Allocate and de-allocate specific resources around each call.&nbsp;
This may slow things down during a series of media actions on a TerminalConnection.&nbsp;
We should probably also track other allocation and free commands to make
sure we don't free resources a concurrent thread or MediaGroup is using.</font></li>

<li>
<font size=-1>Variation on number 2: Provide a X-second garbage collection
period to allocated resources.&nbsp; This could either mean that resource
freeing is delayed by X seconds to speed up subsequent allocations, or
it could be true Resource garbage collection, with an idle resource freed
after some timeout X.</font></li>
</ol>

<h5>
<font size=-1>Solution</font></h5>
<font size=-1>The third option was implemented in an effort to minimize
unnecessary resource allocation and resource allocation thrashing.&nbsp;
This does add to the complexity of the Generic JTAPI Framework, but this
cost is shared among all telephony providers and fits with the framework's
goals of centralizing complexity in the Framework.</font>
<p><font size=-1>When a MediaTerminalProvider is asked to perform a media
service it lazily creates or accesses an associated pseudo media service.&nbsp;
This pseudo service then allocates the necessary resources and starts the
media command.&nbsp; When the command ends, it checks if it is the only
media call currently active.&nbsp; If it is, it puts itself into a "FREEING"
state and starts a garbage collection thread to wait a few seconds and
see if it can still be freed.&nbsp; If another media command is issued
while in the "FREEING" state, the state is changed back to "ALLOCATED"
so that the garbage collector will not try to free the media resources
when it wakes back up.</font></blockquote>

<h4>
<font size=-1>Asyncrhonous Playing/Recording</font></h4>

<blockquote>
<h5>
<font size=-1>Problem</font></h5>
<font size=-1>JTAPI 1.3 media, and consequently the <font color="#000000">TelephonyProvider</font>
interface, define media playing and recording as synchronous methods that
do not return until the playing or recording is complete (including stopped
by some event or RTC action).</font>
<p><font size=-1>JTAPI 1.2 media, however, defines asynchronous "start"
and "stop" pairs for controlling media stream handling.&nbsp; This means
that once a MediaTerminalConnection is issued the "<tt>startPlaying()</tt>"
method, it returns immediately.&nbsp; How do we map this to synchronous
calls.</font>
<h5>
<font size=-1>Options</font></h5>
<font size=-1>The options here are not numerous.&nbsp; Basically we could:</font>
<ol>
<li>
<font size=-1>Alter the <font color="#000000">TelephonyProvider</font>
interface to add new asynchronous play/record commands or flags.</font></li>

<li>
<font size=-1>Change the <font color="#000000">TelephonyProvider</font>
interface semantics to an asynchronous call.&nbsp; This would force the
1.3 media classes to pause its thread until a complete event was received.&nbsp;
Worse, it would expose more of the deprecated paradigm to the telephony
provider implementor and put the complexity with the new implementation
instead of the deprecated implementation.</font></li>

<li>
<font size=-1>Have the 1.2 media classes perform the synchronous media
calls in a separate thread so that the command can return immediately.</font></li>
</ol>

<h5>
<font size=-1>Solution</font></h5>
<font size=-1>The third option was chosen since it isolates the complexity
with the deprecated classes and does not change the media paradigm in the
telephony Provider interface.&nbsp; The "pseudo media service" can lazily
allocate player and recorder threads that take care of the synchronous
media call and allow the MediaTerminalConnection's "<tt>startPlaying()</tt>"
and "<tt>startRecording()</tt>" to return asynchronously.</font>
<p><font size=-1>"<tt>stopPlaying()</tt>" and "<tt>stopRecording()</tt>"
are implemented by sending the "<tt>PlayerConstants.rtca_Stop</tt>" and
"Recorder<tt>Constants.rtca_Stop"</tt> Signals to the telephony media provider.</font>
<h5>
<font size=-1>Consequences</font></h5>

<ol>
<li>
<font size=-1>For a telephony provider to properly support 1.2 media it
must properly implement "<tt>triggerRTC()</tt>" to receive and act on "<tt>PlayerConstants.rtca_Stop</tt>"
and "Recorder<tt>Constants.rtca_Stop" Symbols</tt>.</font></li>
</ol>
</blockquote>

<h4>
<font size=-1>Asyncrhonous Signal Detection</font></h4>

<blockquote>
<h5>
<font size=-1>Problem</font></h5>
<font size=-1>Similar to the asynchronous playing and recording problem,
JTAPI 1.2 media asynchronously starts digit collection whereas the 1.3
media call "<tt>retrieveSignals()</tt>" is synchronous in that it returns
with the digits.&nbsp; In this case, there is also an asynchronous method
for getting signals under JTAPI 1.3: sending a Parameter to the media device
that associates the Symbol key "<tt>p_EnabledEvents</tt>" with the value
Symbol "<tt>ev_SignalDetected</tt>".</font>
<h5>
<font size=-1>Options</font></h5>
<font size=-1>Again, we could:</font>
<ol>
<li>
<font size=-1>Redefine the <font color="#000000">TelephonyProvider</font>
interface to add new retrieval methods</font></li>

<li>
<font size=-1>Change the current <font color="#000000">TelephonyProvider</font>
signal retrieval method to act asynchronously.</font></li>

<li>
<font size=-1>Map the 1.2 signal retrieval methods to Parameters entries
and update the telephony provider's media Parameters for a terminal.</font></li>
</ol>

<h5>
<font size=-1>Solution</font></h5>
<font size=-1>The third choice was the obvious one.&nbsp; The telephony
provider may be signalled with Parameter set changes through the</font>
<blockquote>
<pre><font size=-1>allocateMedia(String terminal, int resources, Dictionary parameters);</font></pre>
</blockquote>
<font size=-1>This allows us to update a set of Parameters associated with
a low-level media resource.&nbsp; When the event is received by the Generic
Framework, it must be caught by the pseudo media service associated with
the MediaTerminalConnection and turned into a deprecated 1.2 media Observer
event.</font>
<h5>
<font size=-1>Consequences</font></h5>

<ol>
<li>
<font size=-1>"<tt>allocateMedia()</tt>" must not only allow the allocation
of new resources, but also the updating of those resources parameter sets.</font></li>

<li>
<font size=-1>A media telephony provider must implement the <tt>"p_EnabledEvents"
-> "ev_SignalDetected"</tt> entry as turning on Signal event reporting
through media events.</font></li>

<li>
<font size=-1>Tuning should not turn off media allocation if it is required
for the updating of a Parameter set.&nbsp; (See the <u>Tuning</u> section)</font></li>
</ol>
</blockquote>

<h3>
<a NAME="Fax"></a>7.10 Fax</h3>
<font size=-1>The 1.3 ECTF-based media architecture discusses MediaGroups
being associated with resources.&nbsp; Furthermore, if you look at the
Symbol set supported provided by the media package, you note the existence
of "Player", "Recorder", "SignalGenerator" and "SignalDetector" oriented
Symbols.&nbsp; We note that S.100-R2 (and its Java implementation R2Symbol)
defines a whole series of FaxReceiver_ and FaxSender_ Symbols as well.&nbsp;
Normally a MediaService creates a MediaGroup, associates with the MediaGroup
certain resources and then implements an interface for those resources.&nbsp;
As of JTAPI 1.3, however, the package does not define a Fax interface.</font>
<p><font size=-1>None-the-less, Fax support in media applications will
be needed by certain applications before the ECTF or the Java Community
Process gets around to correcting this deficiency.&nbsp; After analysing
the issue, it becomes apparent that there are four options:</font>
<ol>
<li>
<font size=-1>Have our implementations of Terminal implement javax.telephony.privatedata.PrivateData.&nbsp;
Then we could send a Command Pattern object to the terminal telling it
to send or receive a fax.&nbsp; This would be mapped to some new set of
methods in <font color="#000000">TelephonyProvider</font>. This technique
is very non-intuitive.</font></li>

<li>
<font size=-1>Use a helper class to translate the fax document to an audio
stream for playing, and visa-versa for recording.&nbsp; For instance, to
fax a document, you use some helper class to turn it into an audio stream
and then tell a MediaService to play the URL for this stream onto a call.&nbsp;
But, of course, Faxes also do handshaking and so this won't work.</font></li>

<li>
<font size=-1>Create two new Media Resources, FaxSender and FaxReceiver,
and then associate these with a MediaService.&nbsp; We'd have to define
some Fax events and Listeners as well and then map their commands into
two new <font color="#000000">TelephonyProvider</font> commands (<tt>sendFax</tt>(...),
<tt>receiveFax</tt>(...)).&nbsp;
This seems the most JTAPIish.&nbsp; On the other hand, it is sure to conflict
with the eventual Fax resource that will be defined in a future version
of JTAPI, leading us to deprecate and replace <font color="#000000">TelephonyProvider</font>
methods.</font></li>

<li>
<font size=-1>Define a "Fax" URL that identifies the stream as one that
should be played or recorded through a fax service.&nbsp; The player or
recorder would determine from the URL that the resource to play or record
was a fax and would do the appropriate handshaking if it supported fax.&nbsp;
If the low-level player or recorder doesn't support fax, it would throw
a MediaResourceException wrapping a ResourceEvent that holds an Error Symbol
(e_BadFileFormat, e_ResourceUnavailable?).&nbsp; The framework would ensure
that a play() command does not mix up fax and non-fax URLs.</font></li>
</ol>
<font size=-1>The last option was chosen as a short-term solution since
it does not require a <font color="#000000">TelephonyProvider</font> interface
change, is relatively explicit in its actions and will not introduce a
competing Fax resource implementation with future JTAPI media support.&nbsp;
The solution is not, however, without its problems.&nbsp; It makes the
interface less strongly typed.&nbsp; It also makes if hard for the proper
allocation of resources.&nbsp; Now, when a Resource is added to a MediaGroup
within a MediaService, the <font color="#000000">TelephonyProvider</font>
is asked to allocate that resource for the terminal.&nbsp; But we don't
differentiate between Audio and Fax resources under this scheme, so the
<font color="#000000">TelephonyProvider</font>
will either:</font>
<ul>
<li>
<font size=-1>Have to allocate possibly unneeded Fax resources.</font></li>

<li>
<font size=-1>Delay Fax resource allocation until it is actually requested,
breaking the paradigm that the creation of a MediaService pre-allocates
that service's resources.&nbsp; If the Fax resource (i.e. dsp) could not
be acquired as needed, a <tt>MediaResourceException</tt> would be thrown
wrapping an "<tt>e_ResourceUnavailable</tt>" Symbol.</font></li>
</ul>
<font size=-1>If the <font color="#000000">TelephonyProvider</font> doesn't
support Fax, it will have to throw a <tt>e_ResourceUnavailable</tt> Symbol
back in a <tt>MediaResourceException</tt>, if it later encounters a Fax
request.</font>
<p><font size=-1>The "play" and "record" methods would define fax requests
as those where the "<tt>streamId</tt>"contained stringified URLs with the
protocol of:</font>
<ol>
<pre><font size=-1>fax://</font></pre>
</ol>
<font size=-1>So, for instance, a document at "http://localhost/docs/12356.jpg"
that was to be faxed to someone would be sent with the command:</font>
<ol>
<pre><font size=-1>PlayerEvent pe = myMediaService.play("fax://http://localhost/docs/12356.jpg", 0, null, null);</font></pre>
</ol>

<h3>
<a NAME="Capabilities"></a>7.11 Capabilities</h3>
</ol>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote><font color="#000000"><font size=-1>JTAPI provides, and the
Generic JTAPI Framework supports, five capability concepts:</font></font></blockquote>
</div>

<ol>
<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote><font color="#000000"><font size=-1><b>Packages</b>. The framework
provides support for the "core" JTAPI classes, as well as parts of callcontrol
(hold, transfer, conference, release), and media.&nbsp; If a JTAPI object
implements an interface from a package, it may implement some of that packages
functionality.&nbsp; So, for instance, to initiate hold on a call we may
perform (assuming "tc" is a TerminalConnection):</font></font>
<blockquote>
<pre><font color="#000000"><font size=-1>if (tc instanceof CallControlTerminalConnection) {
&nbsp;&nbsp;&nbsp; CallControlTerminalConnection cctc = (CallControlTerminalConnection)tc;
&nbsp;&nbsp;&nbsp; try {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cctc.hold();
&nbsp;&nbsp;&nbsp; } catch (MethodNotSupportedException mnse) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // whatever
&nbsp;&nbsp;&nbsp; } ... // other exceptions...
}</font></font></pre>
</blockquote>
</blockquote>
</div>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote><font color="#000000"><font size=-1><b>MethodNotSupportedException</b>.&nbsp;
Most JTAPI calls allow an implementation to opt out of supporting a method
by throwing this exception.&nbsp; See the above example.&nbsp; Usually
Static capabilities should define which methods will throw this exception.</font></font>
<p><font color="#000000"><font size=-1><b>Static capabilities</b>. These
are provided for core and callcontrol JTAPI classes.&nbsp; They define
which methods are actually implemented.</font></font></blockquote>
</div>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote><font color="#000000"><font size=-1><b>Dynamic capabilities</b>.
These are provided for core and callcontrol JTAPI objects. They combine
Static Framework capabilities with instance state information to define
what is currently available for a particular object.</font></font></blockquote>
</div>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote><font color="#000000"><font size=-1><b>Contracts</b>. The new
1.3 media API attempts to move from a capability-based model to a contract-based
model.&nbsp; If a Terminal is an instance of MediaTerminal, all media calls
should be available to a MediaService attached to it.&nbsp; Of course,
reality dictates that the system have some way of throwing an exception
indicating that a resource is not available.</font></font></blockquote>
</div>
</ol>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote><font color="#000000"><font size=-1>The static Capabilities
classes for the Generic JTAPI objects are initialized through reading a
GenericCapabilities.props properties file. Instead of listing all JTAPI
method capabilities, this property file simply lists which TelephonyProvider
call control methods (answer, create, hold, join, release) are supported
by default. From these five capabilities, the system capabilities are all
calculated.</font></font></blockquote>
</div>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote><font color="#000000"><font size=-1>Note that since transfer
and conference are built upon the more basic functions, their capabilities
are calculated from the function availability:</font></font></blockquote>
</div>

<br>&nbsp;
<center><table BORDER CELLSPACING=0 CELLPADDING=4 WIDTH="576" BORDERCOLOR="#000000" >
<caption><b>Basic Capability Mapping</b></caption>

<tr VALIGN=TOP>
<th WIDTH="87">Mapping</th>

<th WIDTH="88">answer</th>

<th WIDTH="88">create</th>

<th WIDTH="88">hold
<br>(and unHold)</th>

<th WIDTH="88">join</th>

<th WIDTH="87">release</th>
</tr>

<tr VALIGN=TOP>
<td WIDTH="87">Consult(digits)</td>

<td WIDTH="88"></td>

<td WIDTH="88">X</td>

<td WIDTH="88">X</td>

<td WIDTH="88"></td>

<td WIDTH="87"></td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="87">Transfer(call)</td>

<td WIDTH="88"></td>

<td WIDTH="88"></td>

<td WIDTH="88"></td>

<td WIDTH="88">X</td>

<td WIDTH="87">X</td>
</tr>

<tr VALIGN=TOP>
<td WIDTH="87">Transfer(digits)</td>

<td WIDTH="88"></td>

<td WIDTH="88">X</td>

<td WIDTH="88">X</td>

<td WIDTH="88">X</td>

<td WIDTH="87">X</td>
</tr>
</table></center>

<blockquote>
<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%"><font color="#000000"><font size=-1>To
read this chart, we note that an unattended transfer requires the following
actions: place existing call on <b>hold, create</b> a new call, <b>join</b>
the calls together, <b>release</b> the transfer controller from the call.&nbsp;
When a TelephonyProvider is allocated, it is asked for its set of overriding
capabilities, based on the same set of five function groups. It is up to
the TelephonyProvider to decide if its capabilities are hard-wired or are
themselves loaded from a Properties file.</font></font></div>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%"><font color="#000000"><font size=-1>Dynamic
Capabilities for a particular instance are calculated using the instance's
state and the static capabilities for that class. For instance, if a Call
object is asked for its dynamic capabilities, it will first create a clone
of the static CallCapabilities object. Then the state of the call is used
to further restrict the capabilities. For instance, if the call is in IDLE
state, its "conference" capability will be turned off, even if the static
capabilities for Call allow conferencing.</font></font></div>

<br>&nbsp;
<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%"><font size=-1><font color="#000000">For
the Generic JTAPI Framework media is supported by providing a </font>telephony<font color="#000000">
provider query method that determines if a given terminal name identifies
a media terminal. This is used during the initialization of the framework
to dynamically determine if an instance of FreeTerminal or FreeMediaTerminal
needs to be instantiated for a particular known and managed terminal name.</font></font></div>

<h3>
<a NAME="Extended JTAPI package support"></a>7.12 Extended JTAPI package
support</h3>
</blockquote>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote><font color="#000000"><font size=-1>Currently the Generic JTAPI
Framework and sub-providers are intended to only support core, specified
call control and some media services. At present, the architecture is not
designed to provide for extensibility to all JTAPI packages. The Generic
JTAPI Framework was originally architected to provide a trade-off between
feature-support and simplicity.&nbsp; This is a common tension in application
development, and more so in Framework development, between the desire to
provide a rich set of features with as little complexity as possible.&nbsp;
The Framework acts as a bridge between the complex JTAPI API and a simpler
TPI that allows telephony boards or IP protocols to be piped into the bottom.&nbsp;
The framework takes care of threading, distribution, event publishing and
other complex but reusable issues and only requires TPI implementations
to implement a relatively small interface.</font></font>
<p><font color="#000000"><font size=-1>Keeping the TPI manageable for implementors
was accomplished, in part, by mapping as many functions as possible into
a few simpler components (akin to RISC in hardware design).&nbsp; For instance
a transfer is mapped to (hold, make-call, join, drop).&nbsp; The other
half of the simplification equation was accomplished by deciding to only
implement a subset of functionality.&nbsp; See the <a href="#Use Cases">Use
Cases</a> for a listing of supported functionality.</font></font>
<p><font size=-1><font color="#000000">So, what happens when someone wants
to add offhook support to CallControlCall?&nbsp; There is no method in
TelephonyProvider that allows this information to be passed to the </font>telephony<font color="#000000">
implementation.&nbsp; And every time we add a new method to TelephonyProvider,
we break all existing TelephonyProvider implementations.&nbsp; This may
be fine while the implementations are all in-house, but as the number grow
and the Generic JTAPI framework starts to be used, we have a serious version
issue.</font></font>
<p><font color="#000000"><font size=-1>The problem isn't constrained to
version control on the TelephonyProvider interface, either.&nbsp; There
is also the problem of interface bloat and JTAPI implementation typing.</font></font>
<p><font color="#000000"><font size=-1>To review, JTAPI provides hint as
to what is implemented in three ways:</font></font>
<ol>
<li>
<font color="#000000"><font size=-1><b>Interface inheritance</b>.&nbsp;
An application can see if a Call has CallControl support by checking if
it implements the CallControlCall interface (i.e. call instanceof CallControlCall).</font></font></li>

<li>
<font color="#000000"><font size=-1><b>Capabilities</b>.&nbsp; An application
can ask for the capabilities of the system and use these object to determine
what is available.&nbsp; For instance if an application asks the Provider
for the CallCapabilities and casts these to CallControlCallCapabilities,
it can then send the Capabilities object the message "canOffHook()", which
returns false.&nbsp; (There are also dynamic capabilities that factor in
the current state of the object,&nbsp; but that is slightly different).</font></font></li>

<li>
<font color="#000000"><font size=-1><b>MethodNotSupported exception</b>.&nbsp;
Just because the Call implementation implements CallControlCall doesn't
mean it provides all CallControlCall methods.&nbsp; It is permissible to
implement most JTAPI interface methods by simply throwing the MethodNotSupportedException.&nbsp;
This should be accompanied by the appropriate Capabilities entry.</font></font></li>
</ol>
<font color="#000000"><font size=-1>How, then, are we to implement this
is the Generic JTAPI framework.&nbsp; There are, for instance, several
sub-interfaces to Terminal -- AgentTerminal, CallControlTerminal, MediaTerminal,
MobileTerminal, PhoneTerminal.&nbsp; Do we have to create all possible
permutations of these and then have them delegate off to package controllers
as appropriate?</font></font>
<h3>
<font color="#000000"><font size=-1>Goals</font></font></h3>

<ol>
<li>
<font color="#000000"><font size=-1>Allows new functionality to be added
to the Generic JTAPI Framework without breaking existing TelephonyProvider
implementations.</font></font></li>

<li>
<font color="#000000"><font size=-1>Gives reasonable JTAPI implementation
information.</font></font></li>

<li>
<font color="#000000"><font size=-1>Allows a TelephonyProvider to implement
a set of functionalities and report which exist to the framework.</font></font></li>

<li>
<font size=-1><font color="#000000">Defines "functional set" dependencies.&nbsp;
An extension that supports callcenter may require functionality only available
if callcontrol is also supported.&nbsp; There is no sense in a </font>telephony<font color="#000000">
provider implementing an extension function set that can't be used since
another required functional set is not provided.</font></font></li>

<li>
<font color="#000000"><font size=-1>Attempt to, as much as possible, leave
the current TPI API alone.</font></font></li>
</ol>
</blockquote>

<blockquote>
<h3>
<font color="#000000"><font size=-1>Options</font></font></h3>

<ol>
<li>
<font color="#000000"><font size=-1>The current TPI provides an initialization
call "public Properties getCapabilities()" that allows a TPI to return
a dictionary of values that defines its operation.&nbsp; Currently these
consist of:</font></font></li>

<ol TYPE=a>
<li>
<font color="#000000"><font size=-1>Base capabilities (i.e. "answer = t"
indicates that the TPI allows calls to be answered.&nbsp; This is more
for creating actual capabilities than changing the framework's behaviour,
but it does indicate that the TerminalConnection.answer() method will probably
return MethodNotSupported from the TelephonyProvider implementation).</font></font></li>

<li>
<font color="#000000"><font size=-1>Implementation <a href="#Tuning">tuning</a>
(i.e. "media = f" indicates that the TPI does not support media.&nbsp;
Terminals that are returned from the system will thus be of type FreeTerminal
instead of FreeMediaTerminal.)&nbsp; This also allows TPI calls that are
NOPs to not be sent (i.e. "allMediaTerminals = t" for an TPI that supports
media means that we don't have to ask the TPI is a particular terminal
should be a FreeMediaTerminal).</font></font></li>
</ol>
<font color="#000000"><font size=-1>We could add to this:</font></font>
<ol START=3 TYPE=a>
<li>
<font color="#000000"><font size=-1>ExtensionPackage naming.&nbsp; The
key namespace beginning with "Extension" is reserved.&nbsp; This is used
to map an extension name to a value of some sort.</font></font></li>
</ol>
<font color="#000000"><font size=-1>What would be a appropriate value?</font></font>
<ol TYPE=I>
<li>
<font size=-1><font color="#000000">The obvious one is passing a class
name.&nbsp; So for instance, if the JTAPI Framework adds a new extension
package called "CallCenter", an TPI that chooses to implement T</font>lephony<font color="#000000">CallCenter
would return, for instance, com.foo.EmCallCenter.&nbsp; So, for instance,
the capabilities Properties dictionary may contain "Extension_CallCenter
-> com.foo.EmCallCenter".&nbsp; The problem with this is that the framework
is than going to have to instantiate this without hooking it into the rest
of the </font>telephony<font color="#000000"> provider implementation.</font></font></li>

<li>
<font size=-1><font color="#000000">We could ignore the value and use the
existence of the key to indicate that the TelephonyProvider also implements
T</font>elephony<font color="#000000">CallCenter.</font></font></li>

<li>
<font size=-1><font color="#000000">Return a method name that can be called
on the TelephonyProvider implementation class using reflection to get the
appropriate class handle.&nbsp; So, if "Extension_CallCenter" points to
"getCallCenter", the framework could use reflection to call the method
"getCallCenter()" on the </font>telephony<font color="#000000"> provider
and return a handle on a new object that implemented the new </font>telephony<font color="#000000">
call control interface.</font></font></li>
</ol>

<li>
<font color="#000000"><font size=-1>As an alternative to Using the capabilities,
why not just inspect the current TelephonyProvider implementation for known
sub-interfaces?&nbsp; Two options are:</font></font></li>

<ol TYPE=a>
<li>
<font color="#000000"><font size=-1>Define a method that can be called
using reflection on the TelephonyProvider instance to get the extension
provider.</font></font></li>

<li>
<font color="#000000"><font size=-1>Just inspect the instance with "instanceof".&nbsp;
So we would issue:</font></font></li>
</ol>

<pre><font color="#000000"><font size=-1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (raw instanceof TelephonyCallCenter) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; callCenterRaw = (TelephonyCallCenter)raw;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</font></font></pre>

<li>
<font color="#000000"><font size=-1>Provide one new method that is an interface
lookup method.&nbsp; This could be in the TelephonyProvider interface or
a sub-interface.&nbsp; If it was in the sub-interface "ExtTelephonyProvider",
we could get a low-level "callcontrol" interface by doing:</font></font></li>

<ol>
<pre><font color="#000000"><font size=-1>&lt;FreeCall.java>
...
public CallCenterTrunks[] getTrunks() {
&nbsp;&nbsp;&nbsp; TelephonyProvider raw = this.getProv().getRaw();
&nbsp;&nbsp;&nbsp; if (raw instanceof ExtTelephonyProvider) {&nbsp;&nbsp;&nbsp; // test if we have a dispatch interface
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object o = ((ExtTelephonyProvider)raw).getExtension("CallCenter");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (o != null &amp;&amp; o instanceof CCTelephonyProvider) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // test if interface found
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String[] trunkNames = ((CCTelephonyProvider)o).getTrunks(this.getCallId());&nbsp;&nbsp;&nbsp; // ask CC TelephonyProvider for trunks
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp; // munge into CallCenterTrunk array and return
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; }
}</font></font></pre>
</ol>
</ol>
<font size=-1><font color="#000000">The major problem with the second architecture
is that it hard-codes the extension functionality into a </font>telephony<font color="#000000">-provider
implementation.&nbsp; For a proxy implementation, such as a remote proxy,
this static capability determination will not work since we need to reflectively
determine the real sub-provider's capabilities.</font></font>
<p><font color="#000000"><font size=-1>Give the remaining two options,
the last seems preferable since it is conceptually simpler, easy to implement
and does not yet again overload the "capabilities" Properties object.&nbsp;
Note that at this time, an extension mechanism has not yet been implemented.</font></font></blockquote>

<blockquote>
<h3>
<font color="#000000"><font size=-1>Example</font></font></h3>
<font color="#000000"><font size=-1>Say we have the Generic JTAPI being
used and with existing TelephonyProviders and we decide to add CallCenter
to it.&nbsp; These are the steps, with players:</font></font>
<ol>
<li>
<font color="#000000"><font size=-1>&lt;<i>Framework</i>>Define a new TelephonyProvider
interface, such as "<tt>CC</tt>TelephonyProvider".</font></font></li>

<li>
<font color="#000000"><font size=-1>&lt;<i>Framework</i>>Update the Generic
JTAPI Framework to make FreeCall also implement CallCenterCall.&nbsp; Likewise
we update the Capabilities classes and the Capabilities default properties
file.</font></font></li>

<li>
<font size=-1><font color="#000000">&lt;<i>Framework</i>>Publish the new
low-level T</font>elephony<font color="#000000"> interface, any new Capabilities
Properties entries which may optionally be added, and the "lookup" name
(<tt>CCTelephonyInterface.LOOKUP_NAME = "CallCenter"</tt>).</font></font></li>

<li>
<font color="#000000"><font size=-1>&lt;<i>Telephony Implementor</i>>Decide
if we wish to implement it.&nbsp; If we do...</font></font></li>

<li>
<font color="#000000"><font size=-1>&lt;<i>Telephony Implementor</i>>Extend
our TelephonyProvider implementation class to also implement the required
interface.</font></font></li>

<li>
<font color="#000000"><font size=-1>&lt;<i>Telephony Implementor</i>>Have
"<tt>getExtension</tt>()" return "this" if "<tt>CCTelephonyInterface.LOOKUP_NAME</tt>"
is passed as the parameter.</font></font></li>
</ol>
<font size=-1><font color="#000000">Alternatively, the </font>telephony<font color="#000000">
implementation could return another object that implements the </font>telephony<font color="#000000">
interface requested.</font></font></blockquote>
</div>

<blockquote>
<h3>
<a NAME="Tuning"></a>7.13 Telephony Provider Tuning</h3>
The framework is loosely coupled from the <font size=-1>telephony</font>
providers that provide it with its telephony functions and do not have
hard-coded interior knowledge of the workings of these <font size=-1>telephony</font>
providers.&nbsp; For this reason, the framework must take a conservative
approach to system management.&nbsp; For instance, the framework will explicitly
request allocation of media resources whenever it thinks these are required.&nbsp;
For many <font size=-1>telephony</font> providers, however, media resources
may essentially be free.&nbsp; In that case, the extra messaging cost,
particularly if a remote proxy provider is used, is a needless waste of
processing cycles (and bandwidth).&nbsp; For this reason, the framework
provides, through the "capabilities" Property object passed back from "getCapabilites()",
the ability to tune the framework.
<p>The four "tuning parameters that may be set are:
<blockquote>&nbsp;
<table BORDER >
<tr BGCOLOR="#C0C0C0">
<th>Key</th>

<th>Default Value</th>

<th>Description</th>
</tr>

<tr>
<td>throttle</td>

<td>
<center>t</center>
</td>

<td>This indicates to the framework that the telephony provider does not
by default send events for all calls.&nbsp; For a large system, reporting
all call events would bog the JTAPI framework down with callback events,
as well as chewing up possibly expensive monitor resources.
<p>If 't' is set, the framework will notify the telephony provider of all
event requests through the "<tt>reportCall</tt>()", "<tt>reportCallsOnAddress()"
and "reportCallsOnTerminal()" <font color="#000000">TelephonyProvider</font></tt>
methods.</td>
</tr>

<tr>
<td>media</td>

<td>
<center>t</center>
</td>

<td><i><a href="#WeakSynchronization">See Section 7.15 Weak Synchronzation</a></i>
<p>This indicates whether the telephony provider supports media.&nbsp;
If it does not, the framework will not bother querying "<tt>isMediaTerminal</tt>()"
when determining which class to create a new Terminal instance from, since
it knows that this method will always return false.</td>
</tr>

<tr>
<td>allMediaTerminals</td>

<td>
<center>f</center>
</td>

<td>If a telephony provider does support media, turning this value to "t"
will indicate to the framework that all terminals support media and so
it does not need to call "<tt>isMediaTerminal</tt>()" when determining
which class to create a new Terminal instance from, since it knows that
this method will always return true.</td>
</tr>

<tr>
<td>allocateMedia</td>

<td>
<center>t</center>
</td>

<td>Some telephony providers may have very cheap media resources, in which
case it is more efficient to always have them allocated to each terminal
rather than receiving a series of allocation and free calls.
<p>If this value is set to "f", the framework will not bother sending "<tt>allocateMedia</tt>()"
and "<tt>freeMedia</tt>()" methods to the telephony provider, unless the
"<tt>allocateMedia</tt>()" method is being used to update the media Parameters
dictionary.</td>
</tr>

<tr>
<td>dynamicAddresses</td>

<td>
<center>f</center>
</td>

<td><i><a href="#DynamicAddressing">See Section 7.14</a></i>
<p>If this is "t", then the Address and Terminal sets associated with the
JTAPI domain are not static.</td>
</tr>
</table>
</blockquote>

<h3>
<a NAME="DynamicAddressing"></a>7.14 Dynamic Domain</h3>

<blockquote><font size=-1>JTAPI assumes that the Address and Terminal set
for a domain remain static over the life of the application.&nbsp; For
some systems, particularily in the VOIP space, this is overly restrictive.</font>
<p><font size=-1>The Generic JTAPI Framework allows TelephonyProviders
to signal through their "getCapabilities()" return Properties that their
Address and Terminal spaces are not static.&nbsp; See section <a href="#Tuning">7.13
Tuning</a>.&nbsp; If this is set to True or "t", then the Framework will
allow applications to query for Addresses or Terminals that were not reported
in any earlier "getAddresses()" or "getTerminals()" call.&nbsp; This query
is passed onto the TelephonyProvider to see if the Address or Terminal
now exists.</font>
<p><font size=-1>Since JTAPI does not support the concept of Listener events
reporting new Address or Terminal availability, the Framework does not
support such a concept.</font></blockquote>

<h3>
<a NAME="WeakSynchronization"></a>7.15 Weak Synchronization</h3>

<blockquote>
<h4>
<a NAME="WeakProblem"></a>Problem</h4>
<font size=-1>The Generic JTAPI Framework without throttling assumes that
the TelephonyProvider will report all state information on all calls (and
Connections and TerminalConnections) in its domain.&nbsp; This may cause
problems for some Telephony implementations.&nbsp; In particular, some
implementations may manage a large domain with a great deal of activity.&nbsp;
Collecting and reporting state changes for all domain objects may, therefore,
become prohibitively expensive due to:</font>
<ol>
<li>
<font size=-1>Implementation monitoring costs.&nbsp; Some platforms may
have significant costs associated with monitoring line or channel behaviour.&nbsp;
Invoking this cost in order to retrieve information that may never be used
may not be pratical.</font></li>

<li>
<font size=-1>Memory size.&nbsp; If thousands of Calls must be maintained
in memory with associated state, Connection and TerminalConnection information,
the JVM memory requirements may get very significant.</font></li>

<li>
<font size=-1>Processing.&nbsp; Receiving and thousands of call events
per second may strain the JVM implementations and lead to poor performance
of unacceptable command latency.</font></li>

<li>
<font size=-1>Network cost.&nbsp; If a TelephonyProvider proxy exists between
the telephony platform and the Generic JTAPI server, then all state update
events must be serialized across the network pipe.&nbsp; This may add significant
network load, including increased collisions, and may cause latency and
responsiveness
degradation.</font></li>
</ol>

<h4>
<a NAME="WeakOptions"></a>Options</h4>
<font size=-1>We are, therefore, left with two options: limit the intended
domain of the Generic JTAPI Framework to small and medium-sized systems
with moderate activity levels; or provide a lazy state synchronization
mechanism.</font>
<h4>
<a NAME="WeakGoals"></a>Goals</h4>
<font size=-1>Primary goals of a lazy state synchronization architecture
include:</font>
<ol>
<li>
<font size=-1>Delay reporting of Call information until the Generic Framework
has requested it.</font></li>

<li>
<font size=-1>Allow Address#getConnections() and Terminal#getTerminalConnections()
to lazily fetch their call association information.</font></li>

<li>
<font size=-1>Provide soft caches to enable Call information to be cached
but reclaimed by the garbage collector when memory becomes tighted.</font></li>

<li>
<font size=-1>Allow for the building of static TelephonyProviders that
do not need to worry about lazy object requests.</font></li>
</ol>
<font size=-1>We should analyze the weak reference access scenarios to
establish what sort of caching, if any, we will require.</font>
<p><font size=-1>Note that we do not require that the framework analyze
dynamic access patterns in order to change the caching mechanisms of the
fly (as HotSpot does with JVMs to optimize calls that are frequently being
called).</font>
<h4>
<a NAME="WeakSimilarProblems"></a>Similar Problems</h4>
<font size=-1>The problem of maintaining an object-hierarchy that is not
fully in-memory is reminiscent of the techniques that are used in Object-Oriented
databases to allow for the flushing in of objects from a persistent store.&nbsp;
Usually such systems allow for a tree of objects to be "trimmed" such that
only a certain depth of the tree is returned and the rest of the tree is
replaced with a placeholder that allows for later flushing out if that
part of the tree is traversed.&nbsp; The cost trade-off here is between
memory usage and initial "fetch" expense versus latter traversal lazy fetching.</font>
<h4>
<a NAME="WeakAnalysis"></a>Analysis</h4>
<font size=-1>First, we should look at the JTAPI architecture that must
be managed.&nbsp; The following diagram presents the relationship between
the Provider and it's Addresses, Terminals and Calls (Connections being
associations between Addresses and Calls and TerminalConnections being
the association between Connections and Terminals.</font>
<p><img SRC="JGF_Weak1.gif" height=629 width=677>
<center><font size=-1>Figure 1: Basic Generic JTAPI class diagram</font></center>

<p><font size=-1>From the JTAPI specification, we can see that the following
are the access methods:</font>
<blockquote>&nbsp;
<table BORDER CELLSPACING=0 >
<tr BGCOLOR="#CCCCCC">
<th>Accessor</th>

<th>Accessed</th>

<th>Method</th>

<th>Type</th>
</tr>

<tr>
<td>Provider</td>

<td>Address</td>

<td>
<pre>getAddresses() throws ResourceUnavailableException</pre>

<pre>getAddress(String name)</pre>
</td>

<td>Domain</td>
</tr>

<tr>
<td>Provider</td>

<td>Terminal</td>

<td>
<pre>getTerminals() throws ResourceUnavailableException</pre>

<pre>getTermnal(String name)</pre>
</td>

<td>Domain</td>
</tr>

<tr>
<td>Provider</td>

<td>Call</td>

<td>
<pre>getCalls() throws ResourceUnavailableException</pre>
</td>

<td>Call</td>
</tr>

<tr>
<td>Address</td>

<td>Connection</td>

<td>
<pre>getConnections()</pre>
</td>

<td>Call</td>
</tr>

<tr>
<td>Address</td>

<td>Terminal</td>

<td>
<pre>getTerminals()</pre>
</td>

<td>Domain</td>
</tr>

<tr>
<td>Terminal</td>

<td>TerminalConnection</td>

<td>
<pre>getTerminalConnections()</pre>
</td>

<td>Call</td>
</tr>

<tr>
<td>Terminal</td>

<td>Address</td>

<td>getAddresses()</td>

<td>Domain</td>
</tr>
</table>
</blockquote>
<font size=-1>We note that we basically have two sets of dynamically loadable
information:</font>
<blockquote>
<h3>
<font size=-1>Domain (Address &lt;-> Terminal)</font></h3>
<font size=-1>These are the sets of Addresses and Terminals that make up
the provider's domain.&nbsp; An application may ask for all the Addresses
or Terminals, or look them up by name.&nbsp; As well, Each Address may
have a number of Terminals associated with it and each Terminal will have
one or more Addresses associated with it.&nbsp; These are static to the
domain.</font>
<h3>
<font size=-1>Call</font></h3>
<font size=-1>This is transient information about current call activity.&nbsp;
Each Address may have any number of Connections associated with it (which
are basically Address to Call association objects).&nbsp; Similarily a
Terminal my have zero or more TerminalConnections associated with it.</font></blockquote>
<font size=-1>The following diagram shows these two sets as blocks within
the object domain.</font></blockquote>
<img SRC="JGF_Weak2.gif" height=525 width=767>
<blockquote>
<center><b>Figure 2: Object Groupings and Accessors</b></center>

<p><font size=-1>We would like to keep these two dynamic sets separate.&nbsp;
So, for instance, one TelephonyProvider implementation may be able to give
a purely static set of Addresses and Terminals which is of a manageable
size, but may not want to automatically incur the cost of reporting all
call events on these sets.</font>
<p><font size=-1>Thus we see that we have two dynamic "fetching" scenarios:</font>
<ol>
<li>
<font size=-1><b>Domain Object Interrogation</b>.&nbsp; Here the Provider
is asked for its set of Addresses or Terminals, or for an Address or Terminal
by name.&nbsp; In the above diagram, the FreeAddress and FreeTerminal classes
are requested.&nbsp; The API allows the implementation to return "ResourceUnavailableException"
to the set accessors but not the name-lookups.&nbsp; It would make sense
to have a Provider that allows "DynamicDomain" to throw the ResourceUnavailableException
and then allow lazy look-ups of individual Terminals and Addresses.</font></li>

<li>
<font size=-1><b>Call Interrogation</b>.&nbsp; Here the Provider asks for
the set of all Calls or the Address or Terminal asks for its set of associated
calls (through the Connection or TerminalConnection association objects).&nbsp;
Here the bottom three classes, FeeCall, FreeConnection and FreeTerminalConnection,
are requested.&nbsp; The API allos the implementation to return "ResourceUnavailableException"
to the global call set accessor, but not the Address or Terminal call set
accessors.</font></li>
</ol>
<font size=-1>From Figure 2 we can also note some other things of importance:</font>
<ul>
<li>
<font size=-1>Terminals and Addresses may be looked up by name or by association
with each other and are also referenced by any active calls that are associated
with them.&nbsp; Therefore it is not sufficient to refetch an Address or
Terminal each time it is looked up, since this may corrupt object identity
if there is already another copy of this object in the system.</font></li>

<li>
<font size=-1>Note that Addresses and Terminals are related, with a Terminal
knowing all the Addresses on it, and an Address knowing all Terminals that
contain it.&nbsp; There are two possibilities for paging in the cross references
between Addresses and Terminals:</font></li>

<ol>
<li>
<font size=-1>Assume that the Terminal-Address graph is not too large.&nbsp;
When an Address name is returned from the TelephonyProvider that is not
currently cached in our system, we perform a recursive search until all
newly reachable Addresses and Terminals have been returned.</font></li>

<li>
<font size=-1>Don't assume that the Address - Terminal sub-graphs are of
moderate size since this may not be a valid assumption.&nbsp; Say an Address
is available on every one of 400 Terminals in a call centre sub-department.&nbsp;
Furthermore, some of these Terminals also hold Addresses on other distant
Address groups.&nbsp; Theoretically there is no reason that doing a full
graph flush may not result in a large number of TelephonyProvider calls
and the flushing out of information on every Address and Terminal in the
domain, if they are all reachable.&nbsp; Instead we should, for Address,
track all of its Terminal names and only use these names to look up Terminals
when the name is traversed.&nbsp; Delaying the graph traversal until first
needed may add some initial lookup time, but will reduce Address lookup,
memory requirements and TelephonyProvider invocations.</font></li>
</ol>

<li>
<font size=-1>Calls and their Connections and TerminalConnections cannot
expand without bound across the whole TelephonyProvider's Call domain,
unless there is only one call currently active.&nbsp; Active calls tend
to have a limited number of Connections associated with them.</font></li>
</ul>

<h4>
<a NAME="WeakArchitecture"></a>Weak Synchronization Architecture</h4>

<blockquote>
<h5>
Paradigm</h5>
<font size=-1>The Generic JTAPI Framework will maintain both Domain and
Call information either statically (by default) or dynamically, based on
TelephonyProvider Capabilities.&nbsp; If looked up dynamically, the reference
will be "softly" or "weakly" held in a reference cache so that the reference
may be cleared once no longer directly accessed by a strong link.&nbsp;
Strong links may include Listeners (since if a listener is registered on
a Call, we want to to get it's state updates and keep the call in memory),
application code, or other directly held dynamic objects (An Address referenced
by a Call that is held by an application).</font>
<h5>
Class Diagram</h5>
</blockquote>
</blockquote>

<center><img SRC="JGF_Weak3.gif" height=525 width=767>
<br><b>Figure 3: Basic Object partition</b></center>

<blockquote>
<blockquote>
<h5>
Reference Determination</h5>
<font size=-1>The following table indicates two things:</font>
<blockquote>
<li>
<font size=-1>The TelephonyCapabilities property that triggers the use
of dynamic lookup and weak caching</font></li>

<li>
<font size=-1>The type of cache used.&nbsp; SoftCaches release softly-reachable
items before a MemoryOutOfError exception is thrown.&nbsp; WeakCaches release
weakly-reachable items during the next garbage collection.</font></li>
</blockquote>
</blockquote>

<table BORDER CELLSPACING=0 >
<tr BGCOLOR="#CCCCCC">
<th></th>

<td>Accessors</td>

<th>Dynamic trigger</th>

<th>Cache Style when dynamic</th>
</tr>

<tr>
<td><b>Domain</b></td>

<td>
<pre>Provider->Address</pre>

<pre>Provider->Terminal</pre>
</td>

<td>ResourceUnavailableException during initialization</td>

<td>SoftCache
<br>(These are domain objects and are likely to be looked up again once
initially active)</td>
</tr>

<tr>
<td></td>

<td>
<pre>Address->Terminal</pre>

<pre>Terminal->Address</pre>
</td>

<td></td>

<td>SoftCache</td>
</tr>

<tr>
<td><b>Call</b></td>

<td>
<pre>Address->Connection</pre>

<pre>Terminal->TerminalConnection</pre>
</td>

<td>throttle = t</td>

<td>WeakCache
<br>(These are transient domain objects that are not as likely to be accessed
in the future)</td>
</tr>
</table>

<blockquote>
<h5>
Shadow References</h5>
<font size=-1>In order to reduce the coupling between object, particularily
those that are not used together frewuently, we need to provide a way of
creating weak or shadow references that do not keep objects from being
garbage collected but do allow for objects to be refetched (paged, lazily
fetched) from the TelephonyProvider when needed.</font>
<p><font size=-1>Here are the references between objects and notes on how
the references are flushed out when needed:</font>
<br>&nbsp;
<table BORDER >
<tr BGCOLOR="#CCCCCC">
<th>Reference Holder
<br>(Source)</th>

<th>Target</th>

<th>Reference Type</th>

<th>Flushing</th>

<th>Notes</th>
</tr>

<tr>
<td>Address</td>

<td>Terminal</td>

<td>String</td>

<td>Asks the DomainMgr for the Terminal with the given String name.&nbsp;
If the DomainMgr has let the Terminal be garbage collected, it recreates
it.</td>

<td>These are the Terminals associated with an Address.&nbsp; This information
is queried from the TelephonyProvider through "getTerminals(String address)"</td>
</tr>

<tr>
<td>Terminal</td>

<td>Address</td>

<td>String</td>

<td>Asks the DomainMgr for the Address with the given String name.&nbsp;
If the DomainMgr has let the Address be garbage collected, it recreates
it.</td>

<td>These are the Addresses associated with a Terminal.&nbsp; This information
is queried from the TelephonyProvider through "getAddresss(String terminal)"</td>
</tr>

<tr>
<td>Address</td>

<td>Connection</td>

<td>ConnectionHolder</td>

<td>The ConnectionHolder has a weak handle to the Connection as well as
storing the CallId and Address name so that the CallMgr can be asked to
refetch the Connection from the TelephonyProvider if needed.</td>

<td>Instead of an Address holding onto all the Connections on the Address,
it holds a collection of ConnectionHolders that act as smart weak references
to the Connection.</td>
</tr>

<tr>
<td>Terminal</td>

<td>TerminalConnection</td>

<td>TermConnHolder</td>

<td>The TermConnHolder has a weak handle to the TerminalConnection as well
as storing the CallId, Address name and Terminal name so that the CallMgr
can be asked to refetch the TerminalConnection from the TelephonyProvider
if needed.</td>

<td>Instead of an Terminal holding onto all the TerminalConnections on
the Terminal, it holds a collection of TermConnHolders that act as smart
weak references to the TerminalConnection.</td>
</tr>

<tr>
<td>Connection</td>

<td>Address</td>

<td>String</td>

<td>Asks the DomainMgr for the Address with the given String name.&nbsp;
If the DomainMgr has let the Address be garbage collected, it recreates
it.</td>

<td>This is the Address that identifies this particular leg of a call.</td>
</tr>

<tr>
<td>TerminalConnection</td>

<td>Terminal</td>

<td>String</td>

<td>Asks the DomainMgr for the Terminal with the given String name.&nbsp;
If the DomainMgr has let the Terminal be garbage collected, it recreates
it.</td>

<td>This is the Terminal that identifies this particular TerminalConnection
part of a Connection.</td>
</tr>
</table>

<p><font size=-1>Note that whereas Addresses and Calls are decoupled from
each other, Call components (Call -> Connection -> TerminalConnection)
are tightly coupled since a call isusually a relatively small set of related
objects that are highly dependend on each other.</font>
<h5>
Manager Class Diagram</h5>
<font size=-1>The following diagram outlines the new manager objects that
make up the core of the Generic JTAPI Architecture.</font>
<br><img SRC="GJF_Weak4.gif" height=628 width=698>
<h5>
<font size=-1>Manager CRC Cards</font></h5>
<font size=-1>These are the simple Class-Responsibility-Collaborator cards
for the major "manager" objects at the core of the Generic JTAPI Framework:</font>
<table BORDER >
<caption><b>GenericProvider</b></caption>

<tr>
<th>Responsibility</th>

<th>Collaborator</th>
</tr>

<tr>
<td>Act as JTAPI Provider</td>

<td></td>
</tr>

<tr>
<td>Hold CallMgr</td>

<td>CallMgr</td>
</tr>

<tr>
<td>Hold DomainMgr</td>

<td>DomainMgr</td>
</tr>

<tr>
<td>Delegate Provider messages off</td>

<td>TelephonyProvider</td>
</tr>

<tr>
<td>Create a TelephonyProvider state callback handler</td>

<td>RawEventHandler</td>
</tr>
</table>

<table BORDER >
<caption><b>CallMgr</b></caption>

<tr>
<th>Responsibility</th>

<th>Collaborator</th>
</tr>

<tr>
<td>Hold weak cache of Calls</td>

<td></td>
</tr>

<tr>
<td>Fault or page Call in when requested</td>

<td>TelephonyProvider</td>
</tr>
</table>

<table BORDER >
<caption><b>DomainMgr</b></caption>

<tr>
<th>Responsibility</th>

<th>Collaborator</th>
</tr>

<tr>
<td>Hold soft cache of Addresses</td>

<td></td>
</tr>

<tr>
<td>Hold soft cache of Terminals</td>

<td></td>
</tr>

<tr>
<td>Fault in Address when requested</td>

<td>TelephonyProvider</td>
</tr>

<tr>
<td>Fault in Terminal when requested</td>

<td>TelephonyProvider</td>
</tr>
</table>

<table BORDER >
<caption><b>RawEventHandler</b></caption>

<tr>
<th>Responsibility</th>

<th>Collaborator</th>
</tr>

<tr>
<td>Receive call state change events</td>

<td>TelephonyProvider</td>
</tr>

<tr>
<td>Delegate off application Listener and Observer events in a separate
thread</td>

<td>BlockManager</td>
</tr>
</table>

<table BORDER >
<caption><b>ListenerManager</b></caption>

<tr>
<th>Responsibility</th>

<th>Collaborator</th>
</tr>

<tr>
<td>Track Listeners and Observers on a Call</td>

<td></td>
</tr>

<tr>
<td>Determine when a Listener is no longer appropriate for a Call</td>

<td></td>
</tr>
</table>

<h5>
Ease of Implementation</h5>
<font size=-1>The addition of dynamic state synchronization to the Generic
JTAPI Framework should not impose undue burden on TelephonyProviders that
support static state updates (i.e. that report all state transitions on
all Domain objects and all Calls).&nbsp; To accomplish this, the following
is a requirement of the new TelephonyProvider changes:</font>
<ul>
<li>
<font size=-1>The new methods may be implemented as NO-OPs if the provider
does not throw ResourceUnavailableException for getAddresses() and does
not have "throttle" set to true.</font></li>

<li>
<font size=-1>A new abstract TelephonyProvider will be provided that remove
the additional methods from the list of methods a class must implement.&nbsp;
TelephoyProviders may choose to extend this abstract class.</font></li>
</ul>

<h5>
Snapshot Data Holders</h5>
<font size=-1>In order to allow for lazy call state fetching, some helper
classes are needed for the simple indication of call state information:</font>
<blockquote>
<pre><font size=-1>public class CallData {
&nbsp;&nbsp;&nbsp; public int callState;
&nbsp;&nbsp;&nbsp; public ConnData[] connections;
}</font></pre>

<pre><font size=-1>public class ConnectionData {
&nbsp;&nbsp;&nbsp; public int connState;
&nbsp;&nbsp;&nbsp; public String address;
&nbsp;&nbsp;&nbsp; public boolean isLocal;
&nbsp;&nbsp;&nbsp; public TCData[] terminalConnections;
}</font></pre>

<pre><font size=-1>public class TCData {
&nbsp;&nbsp;&nbsp; public int tcState;
&nbsp;&nbsp;&nbsp; public TermData terminal;
&nbsp;&nbsp;&nbsp; public String[] terminals;
}</font></pre>

<pre><font size=-1>public class TermData {
&nbsp;&nbsp;&nbsp; public String terminal;
&nbsp;&nbsp;&nbsp; public boolean isMedia;
}</font></pre>
</blockquote>
</blockquote>
</blockquote>

<h2>
<a NAME="Issue Support"></a>8 Issue Support</h2>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%"><font color="#000000"><font size=-1>These
subsections detail how the proposed low-level API provides support for
various key framework requirements.</font></font></div>

<blockquote>
<h3>
<a NAME="AsynchronousSynchronous"></a>8.1 Asynchronous vs. Synchronous</h3>
</blockquote>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote><font size=-1><font color="#000000">We've decided to follow
the JTAPI paradigm as closely as possible, i.e. actions are started more
or less immediately. The </font>telephony<font color="#000000"> provider
may have to hold a thread until an asynchronous event returns. We thought
this was better than making the TelephonyProvider asynchronous, since if
the vendor's API is synchronous, we end up doing needless waiting and event
triggering.</font></font></blockquote>
</div>

<blockquote>
<h3>
<a NAME="Multi-Threading"></a>8.2 Multi-Threading</h3>
</blockquote>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote><font color="#000000"><font size=-1>Wherever modifications
are made to a key collection (i.e. the active call set), care is taken
to update the set in small synchronized methods. Threads are not blocked
by other actions unless absolutely necessary. That is, the API and framework
does not define the synchronization aspect of most calls. Care must be
taken within any implementation to watch out for feature interactions,
and keep any required synchronized blocks as small as possible.</font></font></blockquote>
</div>

<blockquote>
<h3>
<a NAME="Callback Dispatch"></a>8.3 Callback Dispatch</h3>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%"><font color="#000000"><font size=-1>The
event handling model is to have all application Listener or Observer event
dispatch create a Runnable "block" that is placed on a queue to be picked
up and run by a Framework event thread.&nbsp; This architecture accomplishes
two things:</font></font>
<ol>
<li>
<font size=-1><font color="#000000">Event dispatch returns in a timely
fashion to the Framework</font> <font color="#000000">thread, which may
originate from a TelephonyProvider's state callback method, eliminating
the need for the </font>telephony<font color="#000000"> provider to worry
about blocking event calls and setting up its own event dispatch threads.</font></font></li>

<li>
<font color="#000000"><font size=-1>Since only one event management thread
empties the pool, thread creation costs are not a problems and event ordering
is preserved.</font></font></li>
</ol>
</div>

<h3>
<a NAME="Scalability"></a>8.4 Scalability</h3>
</blockquote>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote><font color="#000000"><font size=-1>The Generic JTAPI framework
architecture and TelephonyProvider API tries to facilitate scalability
by ensuring that:</font></font></blockquote>
</div>

<ul>
<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote>
<li>
<font color="#000000"><font size=-1>Methods are only synchronized when
absolutely necessary, and in the smallest methods or blocks possible.</font></font></li>
</blockquote>
</div>

<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<blockquote>
<li>
<font color="#000000"><font size=-1>The pluggable layer allows for the
insertion of proxy layers that allow for the downloading of processing
to other system nodes.</font></font></li>
</blockquote>
</div>
</ul>

<div STYLE="margin-left: 0.02cm; text-indent: -0.02cm; margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%">
<h2>
<a NAME="Future Work"></a>9 Future Work</h2>
</div>

<ol>
<div STYLE="margin-top: 0.42cm; margin-bottom: 0cm; line-height: 100%"><font color="#000000"><font size=-1>The
current JTAPI specification relies on a JTAPI provider having a fixed set
of addresses that it can manage. It is possible that for VOIP networks,
the set of managed addresses and terminals may be subject to flux during
the life of the provider. This is an issue that should be raised with the
JTAPI specification committee.</font></font></div>
</ol>

<div TYPE=FOOTER>
<center>
<hr WIDTH="80%">
<br>&copy; Richard Deadman, Deadman Consulting
<br>http://www.deadman.ca
<br>2002</center>
</div>
</blockquote>

</body>
</html>
